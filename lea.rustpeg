//! Parsing Expression Grammar for Lea
//!
//! Rust PEG generates a parser from this definition at compile time

use std::num::from_str_radix;

use ast::{Literal, Variable, Call, Function, UnOp, BinOp, Block, Expr, Stmt};
use ast::Expr::*;
use ast::Stmt::*;
use ast::UnOp::*;
use ast::BinOp::*;
use ast::Literal::*;
use ast::Variable::*;

#[pub]
whitespace -> ()
    = " "
    / "\t"
    / "\n"
    / "//" [^\n]*
    / "/*" ( [^*] / [*][^/] )* "*/"

#[pub]
ident -> &'input str
    = [_a-zA-Z][_a-zA-Z0-9]* { match_str }

decstr -> &'input str
    = [0-9]+ { match_str }

hexstr -> &'input str
    = [0-9a-fA-F]+ { match_str }

octstr -> &'input str
    = [0-7]+ { match_str }

int_dec -> i64
    = "-"? decstr { match_str.parse().unwrap() }

int_hex -> i64
    = minus:"-"? "0x" hex:hexstr {
        let num = from_str_radix(hex, 16).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

int_oct -> i64
    = minus:"-"? "0o" oct:octstr {
        let num = from_str_radix(oct, 8).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

#[pub]
integer -> i64
    = int_hex
    / int_oct
    / int_dec

/// C-like float (only one part before/after the decimal point is required)
cfloat -> &'input str
    = [0-9]* "." decstr { match_str }
    / decstr "."        { match_str }

/// Float in exponential notation
efloat -> &'input str
    = ( cfloat / decstr ) "e" [+-]? decstr { match_str }

#[pub]
float -> f64
    = "-"? ( efloat / cfloat ) { match_str.parse().unwrap() }

stringchr -> char
    = "\\n" { '\n' }
    / "\\r" { '\r' }
    / "\\t" { '\t' }
    / "\\\\" { '\\' }
    / [^\\"]    { match_str.char_at(0) }    //" to make this work with simple highlighters

stringcontent -> String
    = chrs:stringchr* { chrs.into_iter().collect() }

#[pub]
string -> String
    = '"' content:stringcontent '"' { content }

boolean -> bool
    = "true" { true }
    / "false" { false }

#[pub]
literal -> Literal
    = f:float   { TFloat(f) }
    / i:integer { TInt(i) }
    / s:string  { TStr(s) }
    / b:boolean { TBool(b) }
    / "nil"     { TNil }

binop_mul -> BinOp
    = "*" {BinOp::Mul} / "/" {BinOp::Div} / "%" {BinOp::Mod}

binop_add -> BinOp
    = "+" {BinOp::Add} / "-" {BinOp::Sub}

binop_shift -> BinOp
    = ">>" {BinOp::ShiftR} / "<<" {BinOp::ShiftL}

binop_bor -> BinOp
    = "|" {BinOp::BOr}

binop_xor -> BinOp
    = "^" {BinOp::BXor}

binop_band -> BinOp
    = "&" {BinOp::BAnd}

binop_logic -> BinOp
    = "&&" {BinOp::LAnd} / "||" {BinOp::LOr}

binop_rel -> BinOp
    = "==" {BinOp::Eq} / "!=" {BinOp::NEq} / ">=" {BinOp::GEq} / "<=" {BinOp::LEq}
    / "<" {BinOp::Less} / ">" {BinOp::Greater}

#[pub]
binop -> BinOp
    = binop_add / binop_mul / binop_shift / binop_rel / binop_logic / binop_band / binop_bor
    / binop_xor

#[pub]
unop -> UnOp
    = "-" {UnOp::Negate} / "!" {UnOp::LNot} / "~" {UnOp::BNot} / "#" {UnOp::Len}

/// Returns the expression with which something is indexed
index -> Expr
    = "." id:ident          { ELit(TStr(id.to_string())) }
    / "[" e:expression "]"  { e }

variable -> Variable
    = i:ident idxs:index+    {
        let mut v = VNamed(i.to_string());
        for idx in idxs {
            v = VIndex(Box::new(v), Box::new(idx));
        }

        v
    }
    / i:ident { VNamed(i.to_string()) }

call -> Call
    = what:variable whitespace* "(" args:expression_list ")" { Call(what, args) }

// Atomic expression. Either a literal, a unary operator applied to another atom or a full expr
// inside parentheses. Can not be decomposed any further.
atom -> Expr
    = whitespace* "(" expr:expression ")"   whitespace* { expr }
    / whitespace* lit:literal               whitespace* { ELit(lit) }
    / whitespace* op:unop a:atom            whitespace* { EUnOp(op, Box::new(a)) }
    / whitespace* c:call                    whitespace* { ECall(c) }
    / whitespace* v:variable                whitespace* { EVar(v) }

// The rules below define the operator precedence of all binary operators. The first expr_* rules
// have the highest precedence.

/*

# Precedence levels (in ascending order)

Eq | NEq | LEq | GEq | Less | Greater

LOr | LAnd

BAnd
BXor
BOr
ShiftL | ShiftR

Add | Sub
Mul | Div | Mod

*/

expr_mul -> Expr
    = lhs:atom op:binop_mul rhs:atom { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:atom { a }

expr_add -> Expr
    = lhs:expr_mul op:binop_add rhs:expr_mul { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_mul { a }

expr_shift -> Expr
    = lhs:expr_add op:binop_shift rhs:expr_add { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_add { a }

expr_bor -> Expr
    = lhs:expr_shift op:binop_bor rhs:expr_shift { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_shift { a }

expr_xor -> Expr
    = lhs:expr_bor op:binop_xor rhs:expr_bor { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_bor { a }

expr_band -> Expr
    = lhs:expr_xor op:binop_band rhs:expr_xor { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_xor { a }

expr_logic -> Expr
    = lhs:expr_band op:binop_logic rhs:expr_band { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_band { a }

expr_rel -> Expr
    = lhs:expr_logic op:binop_rel rhs:expr_logic { EBinOp(Box::new(lhs), op, Box::new(rhs)) }
    / a:expr_logic { a }

#[pub]
expression -> Expr
    = expr_rel

// Comma-separated list of expressions (at least one expression is required)
expression_list -> Vec<Expr>
    = e:expression ++ "," { e }

block -> Block
    = s:statement* { Block::new(s) }

if_else -> Block
    = "else" whitespace+ bl:block { bl }

elseif -> (Expr, Block)
    = "elseif" e:expression "then" whitespace+ body:block { (e, body) }

stmt_if -> Stmt
    = "if" cond:expression "then" whitespace+ body:block elifs:elseif* el:if_else? "end" {
        // Build else block for this if statement

        // Start with "pure" else at the end
        let mut myelse = match el {
            None => Block::new(vec![]),
            Some(block) => block,
        };

        for (cond, body) in elifs {
            myelse = Block::new(vec![
                SIf {
                    cond: cond,
                    body: body,
                    el: myelse, // Old else block here
                }
            ]);
        }

        SIf {
            cond: cond,
            body: body,
            el: myelse,
        }
    }

stmt_while -> Stmt
    = "while" cond:expression "do" whitespace+ body:block "end" {
        SWhile { cond: cond, body: body }
    }

stmt_repeat -> Stmt
    = "repeat" whitespace+ body:block "until" cond:expression {
        SRepeat { abort_on: cond, body: body }
    }

_forexp -> Expr
    = "," expression

stmt_for -> Stmt
    = "for" whitespace+ var:ident whitespace* "=" start:expression "," end:expression step:_forexp? "do" whitespace+ body:block "end" {
        SFor {
            var: var.to_string(),
            start: start,
            end: end,
            step: match step {
                None => ELit(TInt(1)),
                Some(e) => e,
            },
            body: body,
        }
    }

_listsep -> ()
    = whitespace* "," whitespace*
// List of comma-separated identifiers with at least one element
identlist -> Vec<String>
    = ids:ident ++ _listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.to_string()); }
        v
    }
// Possibly empty identifier list
eidentlist -> Vec<String>
    = ids:ident ** _listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.to_string()); }
        v
    }

varlist -> Vec<Variable>
    = vars:variable ++ _listsep { vars }

stmt_for_in -> Stmt
    = "for" whitespace+ vars:identlist whitespace+ "in" it:expression_list "do" whitespace+ body:block "end" {
        SForIn {
            vars: vars,
            iter: it,
            body: body,
        }
    }

funcbody -> Function
    = whitespace* "(" whitespace* params:eidentlist whitespace* ")" whitespace* body:block "end" {
        Function(params, body)
    }

stmt_inner -> Stmt
    = stmt_if
    / stmt_while
    / stmt_repeat
    / stmt_for_in
    / stmt_for
    / "do" whitespace+ b:block "end" { SDo(b) }
    / "break" { SBreak }
    / "return" vals:expression_list { SReturn(vals) }
    / "return" { SReturn(vec![]) }
    / c:call { SCall(c) }
    / "function" whitespace+ name:ident f:funcbody { SFunc(VNamed(name.to_string()), f) }
    / "local" whitespace+ "function" whitespace+ name:ident body:funcbody {
        SLFunc(name.to_string(), body)
    }
    / "local" whitespace+ locals:identlist whitespace* "=" exprs:expression_list {
        SDecl(locals, exprs)
    }
    / "local" whitespace+ locals:identlist { SDecl(locals, vec![]) }
    / vars:varlist whitespace* "=" vals:expression_list { SAssign(vars, vals) }

#[pub]
statement -> Stmt
    = whitespace* s:stmt_inner whitespace* { s }
