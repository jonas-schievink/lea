//! Parsing Expression Grammar for Lea
//!
//! rust-peg generates a parser from this definition at compile time

use std::num::from_str_radix;

use ast::{Literal, Variable, Call, Function, UnOp, BinOp, Block, Expr, Stmt};
use ast::Expr::*;
use ast::Stmt::*;
use ast::UnOp::*;
use ast::BinOp::*;
use ast::Literal::*;
use ast::Variable::*;

whitespace -> ()
    = " "
    / "\t"
    / "\n"
    / "//" [^\n]*
    / "/*" ( [^*] / [*][^/] )* "*/"

#[pub]
ident -> &'input str
    = [_a-zA-Z][_a-zA-Z0-9]* { match_str }

decstr -> &'input str
    = [0-9]+ { match_str }

hexstr -> &'input str
    = [0-9a-fA-F]+ { match_str }

octstr -> &'input str
    = [0-7]+ { match_str }

int_dec -> i64
    = "-"? decstr { match_str.parse().unwrap() }

int_hex -> i64
    = minus:"-"? "0x" hex:hexstr {
        let num = from_str_radix(hex, 16).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

int_oct -> i64
    = minus:"-"? "0o" oct:octstr {
        let num = from_str_radix(oct, 8).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

integer -> i64
    = int_hex
    / int_oct
    / int_dec

/// C-like float (only one part before/after the decimal point is required)
cfloat -> &'input str
    = [0-9]* "." decstr { match_str }
    / decstr "."        { match_str }

/// Float in exponential notation
efloat -> &'input str
    = ( cfloat / decstr ) "e" [+-]? decstr { match_str }

float -> f64
    = "-"? ( efloat / cfloat ) { match_str.parse().unwrap() }

stringchr -> char
    = "\\n" { '\n' }
    / "\\r" { '\r' }
    / "\\t" { '\t' }
    / "\\\\" { '\\' }
    / [^\\"]    { match_str.char_at(0) }    //" to make this work with simple highlighters

stringcontent -> String
    = chrs:stringchr* { chrs.into_iter().collect() }

string -> String
    = '"' content:stringcontent '"' { content }

boolean -> bool
    = "true" { true }
    / "false" { false }

#[pub]
literal -> Literal
    = f:float   { TFloat(f) }
    / i:integer { TInt(i) }
    / s:string  { TStr(s) }
    / b:boolean { TBool(b) }
    / "nil"     { TNil }

binop_mul -> BinOp
    = "*" {BinOp::Mul} / "/" {BinOp::Div} / "%" {BinOp::Mod}

binop_add -> BinOp
    = "+" {BinOp::Add} / "-" {BinOp::Sub}

binop_shift -> BinOp
    = ">>" {BinOp::ShiftR} / "<<" {BinOp::ShiftL}

binop_bor -> BinOp
    = "|" {BinOp::BOr}

binop_xor -> BinOp
    = "^" {BinOp::BXor}

binop_band -> BinOp
    = "&" {BinOp::BAnd}

binop_logic -> BinOp
    = "&&" {BinOp::LAnd} / "||" {BinOp::LOr}

binop_rel -> BinOp
    = "==" {BinOp::Eq} / "!=" {BinOp::NEq} / ">=" {BinOp::GEq} / "<=" {BinOp::LEq}
    / "<" {BinOp::Less} / ">" {BinOp::Greater}

binop -> BinOp
    = binop_add / binop_mul / binop_shift / binop_rel / binop_logic / binop_band / binop_bor
    / binop_xor

unop -> UnOp
    = "-" {UnOp::Negate} / "!" {UnOp::LNot} / "~" {UnOp::BNot} / "#" {UnOp::Len}

listsep -> ()
    = whitespace* "," whitespace*

/// Returns the expression with which something is indexed
index -> Expr
    = "." id:ident          { ELit(TStr(id.to_string())) }
    / "[" e:expression "]"  { e }

variable -> Variable
    = i:ident idxs:index+    {
        let mut v = VNamed(i.to_string());
        for idx in idxs {
            v = VIndex(Box::new(v), Box::new(idx));
        }

        v
    }
    / i:ident { VNamed(i.to_string()) }

callargs -> Vec<Expr>
    = whitespace* "(" args:expression ** listsep whitespace* ")" { args }

call -> Call
    = v:variable args:callargs+ {
        let mut it = args.into_iter();
        let mut what = Call(Box::new(EVar(v)), it.next().unwrap());

        for list in it {
            what = Call(Box::new(ECall(what)), list);
        }

        what
    }

atom_inner -> Expr
    = "(" expr:expression ")" { expr }
    / "..." { EVarArgs }
    / lit:literal { ELit(lit) }
    / op:unop a:atom { EUnOp(op, Box::new(a)) }
    / c:call { ECall(c) }
    / v:variable { EVar(v) }

// Atomic expression. Either a literal, a unary operator applied to another atom or a full expr
// inside parentheses. Can not be decomposed any further.
atom -> Expr
    = whitespace* a:atom_inner whitespace* { a }

// The rules below define the operator precedence of all binary operators. The first expr_* rules
// have the highest precedence.

/*

# Precedence levels (in ascending order)

Eq | NEq | LEq | GEq | Less | Greater

LOr | LAnd

BAnd
BXor
BOr
ShiftL | ShiftR

Add | Sub
Mul | Div | Mod

*/

kvpair_inner -> (Expr, Expr)
    = "[" key:expression "]" whitespace* "=" whitespace* val:expression { (key, val) }
    / id:ident whitespace* "=" whitespace* val:expression { (ELit(TStr(id.to_string())), val) }

kvpair -> (Expr, Expr)
    = whitespace* kv:kvpair_inner whitespace* { kv }

tablecons -> Vec<(Expr, Expr)>
    = "{" pairs:kvpair ++ listsep listsep? "}" { pairs }
    / "{" whitespace* "}" { Vec::new() }

arraycons -> Vec<Expr>
    = "[" vals:expression_list listsep? "]" { vals }
    / "[" whitespace* "]" { Vec::new() }

expr_special -> Expr
    = t:tablecons { ETable(t) }
    / a:arraycons { EArray(a) }
    / "function" f:funcbody { EFunc(f) }

expr_rest -> (BinOp, Expr)
    = op:binop r:atom { (op, r) }

expr_inner -> Expr
    = expr_special
    / l:atom rest:expr_rest* { ERawOp(Box::new(l), rest) }

#[pub]
expression -> Expr
    = whitespace* e:expr_inner whitespace* { e }

// Comma-separated list of expressions (at least one expression is required)
expression_list -> Vec<Expr>
    = e:expression ++ listsep { e }

if_else -> Block
    = "else" whitespace+ bl:block { bl }

elseif -> (Expr, Block)
    = "elseif" e:expression "then" whitespace+ body:block { (e, body) }

stmt_if -> Stmt
    = "if" cond:expression "then" whitespace+ body:block elifs:elseif* el:if_else? "end" {
        // Build else block for this if statement

        // Start with "pure" else at the end
        let mut myelse = match el {
            None => Block::new(vec![]),
            Some(block) => block,
        };

        for (cond, body) in elifs {
            myelse = Block::new(vec![
                SIf {
                    cond: cond,
                    body: body,
                    el: myelse, // Old else block here
                }
            ]);
        }

        SIf {
            cond: cond,
            body: body,
            el: myelse,
        }
    }

stmt_while -> Stmt
    = "while" cond:expression "do" whitespace+ body:block "end" {
        SWhile { cond: cond, body: body }
    }

stmt_repeat -> Stmt
    = "repeat" whitespace+ body:block "until" cond:expression {
        SRepeat { abort_on: cond, body: body }
    }

// List of comma-separated identifiers with at least one element
identlist -> Vec<String>
    = ids:ident ++ listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.to_string()); }
        v
    }

// Possibly empty identifier list
eidentlist -> Vec<String>
    = ids:ident ** listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.to_string()); }
        v
    }

varlist -> Vec<Variable>
    = vars:variable ++ listsep { vars }

_forexp -> Expr
    = "," expression

stmt_for -> Stmt
    = "for" whitespace+ var:ident whitespace* "=" start:expression "," end:expression step:_forexp? "do" whitespace+ body:block "end" {
        SFor {
            var: var.to_string(),
            start: start,
            end: end,
            step: match step {
                None => ELit(TInt(1)),
                Some(e) => e,
            },
            body: body,
        }
    }

stmt_for_in -> Stmt
    = "for" whitespace+ vars:identlist whitespace+ "in" it:expression_list "do" whitespace+ body:block "end" {
        SForIn {
            vars: vars,
            iter: it,
            body: body,
        }
    }

varargs_def -> ()
    = whitespace* listsep whitespace* "..."

// Returns the parameter list and a boolean indicating whether the function takes variable args
funcparams -> (Vec<String>, bool)
    = "(" whitespace* params:identlist va:varargs_def? whitespace* ")" {
        (params, match va { None => false, Some(..) => true})
    }
    / "(" whitespace* "..." whitespace* ")" { (Vec::new(), true) }
    / "(" whitespace* ")" { (Vec::new(), false) }

funcbody -> Function
    = whitespace* params:funcparams whitespace* body:block "end" {
        let (pars, varargs) = params;
        Function {
            params: pars,
            varargs: varargs,
            body: body,
        }
    }

stmt_inner -> Stmt
    = stmt_if
    / stmt_while
    / stmt_repeat
    / stmt_for_in
    / stmt_for
    / "do" whitespace+ b:block "end" { SDo(b) }
    / "break" { SBreak }
    / "return" vals:expression_list { SReturn(vals) }
    / "return" { SReturn(vec![]) }
    / "function" whitespace+ name:ident f:funcbody { SFunc(VNamed(name.to_string()), f) }
    / "local" whitespace+ "function" whitespace+ name:ident body:funcbody {
        SLFunc(name.to_string(), body)
    }
    / "local" whitespace+ locals:identlist whitespace* "=" exprs:expression_list {
        SDecl(locals, exprs)
    }
    / "local" whitespace+ locals:identlist { SDecl(locals, vec![]) }
    / c:call { SCall(c) }
    / vars:varlist whitespace* "=" vals:expression_list { SAssign(vars, vals) }

#[pub]
statement -> Stmt
    = whitespace* s:stmt_inner whitespace* { s }

#[pub]
block -> Block
    = s:statement* { Block::new(s) }
