//! This module contains the compiler, resolver and AST

mod expr_parser;
pub mod transform;
pub mod ast;
pub mod check;
pub mod parser;
pub mod prettyprint;
pub mod resolve;
pub mod span;
pub mod visit;

pub use self::CompileError::*;

use program::Program;
use self::ast::Function;
use self::transform::Transform;
use self::span::Span;

use std::default::Default;

/// Defines options that can be used to tweak the compilation process (optimizations, linters, ...)
pub struct CompileConfig {
    /// AST transforms to apply. All transforms are applied in the order specified here.
    trans: Vec<Transform>,
}

impl Default for CompileConfig {
    /// Creates a default `CompileConfig` that applies the default set of optimizations and linters
    fn default() -> CompileConfig {
        CompileConfig {
            trans: vec![transform::globalwrite::run],
        }
    }
}

/// Kinds of errors that can occur when compiling code
#[derive(Debug)]
pub enum CompileError {
    /// The input source code could not be parsed
    ErrParse(parser::ParseError),

    /// The checker encountered one or more problems
    ErrCheck(Vec<check::CheckError>),
}

/// A non-fatal warning emitted by an AST transform
#[derive(Clone, Debug)]
pub struct Warning {
    span: Span,
    message: String,
}

impl Warning {
    pub fn new(span: Span, message: String) -> Warning {
        Warning {
            span: span,
            message: message,
        }
    }

    pub fn format(&self, code: &str, source_name: &str) -> String {
        let (startline, _end) = self.span.get_lines(code);
        let mut res = format!("{}:{}: warning: {} \n", source_name, startline, self.message);
        res.push_str(self.span.format(code, source_name).as_slice());
        res
    }
}

/// Output of a successful compilation.
pub struct CompileOutput {
    /// Warnings generated by Linters
    warns: Vec<Warning>,
}

impl CompileOutput {
    pub fn get_warns(&self) -> &[Warning] {
        self.warns.as_slice()
    }
}

/// The result of a compilation.
///
/// If the compilation is successful, this returns the function id of the main function. This
/// function can be instantiated by the VM and will execute the program.
pub type CompileResult = Result<CompileOutput, CompileError>;

/// Parses and checks the given source code. Returns a valid `Function` node on success.
///
/// If this succeeds, this means that the program described by the source code is valid and can be
/// compiled.
pub fn parse_and_check(code: &str) -> Result<Function, CompileError> {
    match parser::parse_main(code) {
        Err(e) => Err(ErrParse(e)),
        Ok(mut main) => {
            match check::check_func(&mut main) {
                Err(errs) => Err(ErrCheck(errs)),
                Ok(()) => {
                    Ok(main)
                }
            }
        }
    }
}

/// Applies all transforms in the given `transforms` vector to the `main` function. Returns all
/// warnings generated by the transforms. `main` must be a resolved main function.
pub fn apply_transforms(mut main: &mut Function, transforms: &Vec<Transform>) -> Vec<Warning> {
    let mut warnings = vec![];
    for tr in transforms {
        let mut new_warns = tr(&mut main);
        warnings.append(&mut new_warns);
    }

    warnings
}

/// Compiles source code into a program.
///
/// # Parameters
///
/// * `p` - The `Program` to which the compiled functions and constants are added to
/// * `code` - The source code to compile
/// * `source_name` - The name of this source code. Used when reporting errors. This should be
///   a file name or something similar.
pub fn compile_str(_p: &mut Program, code: &str, _source_name: &str,
        conf: &CompileConfig) -> CompileResult {
    let mut main = try!(parse_and_check(code));
    resolve::resolve_func(&mut main);

    let warnings = apply_transforms(&mut main, &conf.trans);

    Ok(CompileOutput {
        warns: warnings,
    })
}
