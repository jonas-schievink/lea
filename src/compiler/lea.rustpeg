//! Parsing Expression Grammar for Lea
//!
//! rust-peg generates a parser from this definition at compile time

use std::num::from_str_radix;
use std::mem;

use compiler::span::{Span, Spanned, mkspanned};
use compiler::ast::*;
use op::*;

mlcomment_inner -> ()
    = "=" mlcomment_inner "="
    / "["  "]"

comment -> ()
    = "--[" mlcomment_inner "]"
    / "/*" ( [^*] / [*][^/] )* "*/"
    / ( "//" / "--" ) [^\n]*

real_whitespace -> ()
    = " "
    / "\t"
    / "\n"
    / "\r"

whitespace -> ()
    = real_whitespace
    / comment

#[pub]
ident -> Spanned<&'input str>
    = [_a-zA-Z][_a-zA-Z0-9]* { mkspanned(match_str, start_pos, pos) }

decdigit -> char
    = [0-9] { match_str.char_at(0) }

decstr -> &'input str
    = decdigit+ { match_str }

hexdigit -> char
    = [0-9a-fA-F] { match_str.char_at(0) }

hexstr -> &'input str
    = hexdigit+ { match_str }

octstr -> &'input str
    = [0-7]+ { match_str }

int_dec -> i64
    = "-"? decstr { match_str.parse().unwrap() }

int_hex -> i64
    = minus:"-"? "0x" hex:hexstr {
        let num = from_str_radix(hex, 16).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

int_oct -> i64
    = minus:"-"? "0o" oct:octstr {
        let num = from_str_radix(oct, 8).unwrap();
        match minus {
            None => num,
            Some(_) => -num,
        }
    }

integer -> i64
    = int_hex
    / int_oct
    / int_dec

/// C-like float (only one part before/after the decimal point is required)
cfloat -> &'input str
    = [0-9]* "." decstr { match_str }
    / decstr "." ! "."  { match_str }   // no second "." allowed, since that's the concat operator

/// Float in exponential notation
efloat -> &'input str
    = ( cfloat / decstr ) "e" [+-]? decstr { match_str }

float -> f64
    = "-"? ( efloat / cfloat ) { match_str.parse().unwrap() }

/// Matches the decimal notation of a single byte: 0-255
dec_byte -> u8
    = [01] decdigit{,2} { match_str.parse().unwrap() }
    / "2" [0-4] [0-9] { match_str.parse().unwrap() }
    / "25" [0-5] { match_str.parse().unwrap() }
    / decdigit{1,2} { match_str.parse().unwrap() }

esc_seq -> char
    = "\\a" { '\x07' }  // bell
    / "\\b" { '\x08' }  // backspace
    / "\\f" { '\x0c' }  // form feed
    / "\\n" { '\n' }
    / "\\r" { '\r' }
    / "\\t" { '\t' }
    / "\\v" { '\x0b' }  // vertical tab
    / "\\\\" { '\\' }
    / "\\\"" { '\"' }
    / "\\'" { '\'' }
    / "\\\n" { '\n' }
    / "\\x" digits:hexdigit{2} {
        let string: String = digits.into_iter().collect();
        let i: u8 = from_str_radix(string.as_ref(), 16).unwrap();

        i as char
    }
    / "\\" val:dec_byte { val as char }
    / "\\0" { 0 as char }

/// \z will skip all whitespace that follows it. Useful for breaking string literals into multiple
/// lines: "bla\z
///         bla"
blank_esc -> ()
    = "\\z" real_whitespace*

_double_quote_content -> char
    = esc_seq
    / blank_esc _double_quote_content
    / [^\\"\n]  { match_str.char_at(0) }    //" to make this work with simple highlighters

_single_quote_content -> char
    = esc_seq
    / blank_esc _single_quote_content
    / [^\\'\n]  { match_str.char_at(0) }

string -> String
    = '"' chars:_double_quote_content* blank_esc? '"' { chars.into_iter().collect() }
    / '\'' chars:_single_quote_content* blank_esc? '\'' { chars.into_iter().collect() }

boolean -> bool
    = "true" { true }
    / "false" { false }

_literal -> Literal
    = f:float   { TFloat(f) }
    / i:integer { TInt(i) }
    / s:string  { TStr(s) }
    / b:boolean { TBool(b) }
    / "nil"     { TNil }

#[pub]
literal -> Spanned<Literal>
    = l:_literal { mkspanned(l, start_pos, pos) }

binop -> BinOp
    = "==" {BinOp::Eq} / "!=" {BinOp::NEq} / "~=" {BinOp::NEqLua} / ">=" {BinOp::GEq}
    / "<=" {BinOp::LEq} / ">>" {BinOp::ShiftR} / "<<" {BinOp::ShiftL} / "<" {BinOp::Less}
    / ">" {BinOp::Greater} / "&&" {BinOp::LAnd} / "and" {BinOp::LAndLua} / "||" {BinOp::LOr}
    / "or" {BinOp::LOrLua} / "&" {BinOp::BAnd} / "~" {BinOp::BXor} / "|" {BinOp::BOr}
    / "+" {BinOp::Add} / "-" {BinOp::Sub} / "*" {BinOp::Mul} / "/" {BinOp::Div} / "%" {BinOp::Mod}
    / "^" {BinOp::Pow} / ".." {BinOp::Concat}

unop -> UnOp
    = "-" {UnOp::Negate} / "!" {UnOp::LNot} / "not" {UnOp::LNotLua} / "~" {UnOp::BNot}
    / "#" {UnOp::Len}

listsep -> ()
    = whitespace* "," whitespace*

/// Returns the expression with which something is indexed and a boolean indicating if dot-notation
/// was used.
index -> (Expr, bool)
    = "." id:ident          { (mkspanned(ELit(TStr(id.value.to_string())), start_pos, pos), true) }
    / "[" e:expression "]"  { (mkspanned(e.value, start_pos, pos), false) }

variable -> Variable
    = i:ident idxs:index+    {
        let mut v = Spanned::new(i.span, VNamed(i.value.to_string()));
        for idx in idxs {
            let (expr, dot) = idx;

            let start = v.span.start;
            let end = expr.span.start + expr.span.len;

            if dot {
                if let ELit(TStr(s)) = expr.value {
                    v = mkspanned(VDotIndex(Box::new(v), s), start, end);
                    continue;
                }
            }
            v = mkspanned(VIndex(Box::new(v), Box::new(expr)), start, end);
        }

        v
    }
    / i:ident { mkspanned(VNamed(i.value.to_string()), start_pos, pos) }

/// Returns the expressions to pass as arguments, and a bool indicating if the "special" form was
/// used (ie. `StringCall` or `TableCall`)
callargs -> CallArgs
    = whitespace* "(" args:expression ** listsep whitespace* ")" { CallArgs::Normal(args) }
    / whitespace* strn:string { CallArgs::String(strn) }
    / whitespace* tbl:tablecons { CallArgs::Table(tbl) }

methodname -> Spanned<&'input str>
    = ":" ident

call -> Call
    = v:variable name:methodname? args:callargs+ {
        let mut it = args.into_iter();
        let first_args = it.next().unwrap();
        let span = v.span.clone();
        let callee = Box::new(Spanned::new(v.span.clone(), EVar(v.clone())));
        let mut what = Spanned::new(v.span.clone(), match name {
            None => SimpleCall(callee, first_args),
            Some(name) => MethodCall(callee, Spanned::new(name.span, name.to_string()), first_args),
        });

        for list in it {
            what = Spanned::new(v.span.clone(),
                SimpleCall(Box::new(Spanned::new(what.span, ECall(what.value))), list));
        }

        what.value
    }

atom_inner -> Expr
    = "(" expr:expression ")" { mkspanned(expr.value, start_pos, pos) }
    / "..." { mkspanned(EVarArgs, start_pos, pos) }
    / lit:literal { Spanned::new(lit.span, ELit(lit.value)) }
    / op:unop a:atom { mkspanned(EUnOp(op, Box::new(a)), start_pos, pos) }
    / c:call { mkspanned(ECall(c), start_pos, pos) }
    / v:variable { Spanned::new(v.span, EVar(v)) }

// Atomic expression. Either a literal, a unary operator applied to another atom or a full expr
// inside parentheses.
atom -> Expr
    = whitespace* a:atom_inner whitespace* { a }

kvpair_inner -> (Expr, Expr)
    = "[" key:expression "]" whitespace* "=" whitespace* val:expression { (key, val) }
    / id:ident whitespace* "=" whitespace* val:expression {
        (Spanned::new(id.span, ELit(TStr(id.value.to_string()))), val)
    }

kvpair -> (Expr, Expr)
    = whitespace* kv:kvpair_inner whitespace* { kv }

tablecons -> Vec<(Expr, Expr)>
    = "{" pairs:kvpair ++ listsep listsep? "}" { pairs }
    / "{" whitespace* "}" { Vec::new() }

arraycons -> Vec<Expr>
    = "[" vals:expression_list listsep? "]" { vals }
    / "[" whitespace* "]" { Vec::new() }

expr_special -> Expr
    = t:tablecons { mkspanned(ETable(t), start_pos, pos) }
    / a:arraycons { mkspanned(EArray(a), start_pos, pos) }
    / "function" f:funcbody { mkspanned(EFunc(f), start_pos, pos) }

expr_rest -> (BinOp, Expr)
    = op:binop r:atom { (op, r) }

expr_inner -> Expr
    = expr_special
    / l:atom rest:expr_rest* { mkspanned(ERawOp(Box::new(l), rest), start_pos, pos) }

#[pub]
expression -> Expr
    = whitespace* e:expr_inner whitespace* { e }

// Comma-separated list of expressions (at least one expression is required)
expression_list -> Vec<Expr>
    = e:expression ++ listsep { e }

if_else -> Block
    = "else" whitespace+ bl:block { bl }

elseif -> Spanned<(Expr, Block)>
    = "elseif" e:expression "then" whitespace+ body:block { mkspanned((e, body), start_pos, pos) }

stmt_if -> Stmt
    = "if" cond:expression "then" whitespace+ body:block elifs:elseif* el:if_else? "end" {
        // Build else block for this if statement

        // Start with "pure" else at the end
        let mut myelse = match el {
            None => Block::new(vec![], Span::new(pos, pos)),
            Some(block) => block,
        };

        for elif in elifs {
            let (cond, body) = elif.value;

            myelse = Block::new(vec![
                Spanned::new(elif.span, SIf {
                    cond: cond,
                    body: body,
                    el: myelse, // Old else block here
                }),
            ], elif.span);
        }

        mkspanned(SIf {
            cond: cond,
            body: body,
            el: myelse,
        }, start_pos, pos)
    }

stmt_while -> Stmt
    = "while" cond:expression "do" whitespace+ body:block "end" {
        mkspanned(SWhile { cond: cond, body: body }, start_pos, pos)
    }

stmt_repeat -> Stmt
    = "repeat" whitespace+ body:block "until" cond:expression {
        mkspanned(SRepeat { abort_on: cond, body: body }, start_pos, pos)
    }

// List of comma-separated identifiers with at least one element
identlist -> Vec<String>
    = ids:ident ++ listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.value.to_string()); }
        v
    }

// Possibly empty identifier list
eidentlist -> Vec<String>
    = ids:ident ** listsep {
        let mut v = Vec::with_capacity(ids.len());
        for id in ids { v.push(id.value.to_string()); }
        v
    }

varlist -> Vec<Variable>
    = vars:variable ++ listsep { vars }

_forexp -> Expr
    = "," expression

stmt_for -> Stmt
    = "for" whitespace+ var:ident whitespace* "=" start:expression "," end:expression step:_forexp? "do" whitespace+ body:block "end" {
        let stepspan = end.span;
        mkspanned(SFor {
            var: var.value.to_string(),
            start: start,
            end: end,
            step: match step {
                None => Spanned::new(stepspan, ELit(TInt(1))),
                Some(e) => e,
            },
            body: body,
        }, start_pos, pos)
    }

stmt_for_in -> Stmt
    = "for" whitespace+ vars:identlist whitespace+ "in" it:expression_list "do" whitespace+ body:block "end" {
        mkspanned(SForIn {
            vars: vars,
            iter: it,
            body: body,
        }, start_pos, pos)
    }

varargs_def -> ()
    = whitespace* listsep whitespace* "..."

// Returns the parameter list and a boolean indicating whether the function takes variable args
funcparams -> (Vec<String>, bool)
    = "(" whitespace* params:identlist va:varargs_def? whitespace* ")" {
        (params, match va { None => false, Some(..) => true})
    }
    / "(" whitespace* "..." whitespace* ")" { (Vec::new(), true) }
    / "(" whitespace* ")" { (Vec::new(), false) }

funcbody -> Function
    = whitespace* params:funcparams whitespace* body:block "end" {
        let (pars, varargs) = params;
        Function::new(pars, varargs, body)
    }

stmt_func -> Stmt
    = "function" whitespace+ name:ident f:funcbody {
        mkspanned(SFunc(Spanned::new(name.span, VNamed(name.value.to_string())), f), start_pos, pos)
    }

stmt_lfunc -> Stmt
    = "local" whitespace+ "function" whitespace+ name:ident f:funcbody {
        mkspanned(SLFunc(name.value.to_string(), f), start_pos, pos)
    }

stmt_inner -> Stmt
    = stmt_if
    / stmt_while
    / stmt_repeat
    / stmt_for_in
    / stmt_for
    / stmt_func
    / stmt_lfunc
    / "do" whitespace+ b:block "end" { mkspanned(SDo(b), start_pos, pos) }
    / "break" { mkspanned(SBreak, start_pos, pos) }
    / "return" vals:expression_list { mkspanned(SReturn(vals), start_pos, pos) }
    / "return" { mkspanned(SReturn(vec![]), start_pos, pos) }
    / "local" whitespace+ locals:identlist whitespace* "=" exprs:expression_list {
        mkspanned(SDecl(locals, exprs), start_pos, pos)
    }
    / "local" whitespace+ locals:identlist { mkspanned(SDecl(locals, vec![]), start_pos, pos) }
    / c:call { mkspanned(SCall(c), start_pos, pos) }
    / vars:varlist whitespace* "=" vals:expression_list {
        mkspanned(SAssign(vars, vals), start_pos, pos)
    }

#[pub]
statement -> Stmt
    = whitespace* s:stmt_inner whitespace* { s }

#[pub]
block -> Block
    = s:statement* { Block::new(s, Span::new(start_pos, pos)) }
