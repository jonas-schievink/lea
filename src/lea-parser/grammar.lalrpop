use std::mem;

use expr_parser::build_tree;
use span::{Span, Spanned, mkspanned};
use op::*;
use parsetree::*;

use lea_core::Const;

grammar["LALR(1)"];

/// Utility macro that wraps a `T` in a `Spanned<T>`, attaches its span and parses all preceding
/// comments.
#[inline]
Spanned<T>: Spanned<T> = {
    <start:@L> <t:T> <end:@R> => {
        Spanned::new(Span::new(start, end), t)
    }
};

#[inline]
RawIdent = r"[_a-zA-Z][_a-zA-Z0-9]*";

pub Ident: Spanned<&'input str> = Spanned<RawIdent>;

/// List of `T`s, seperated by `,`. No trailing `,` is allowed.
Comma<T, Empty>: Vec<T> = {
    <head:(<T> ",")*> <last:T> if Empty == "NonEmpty" => {
        let mut head = head;
        head.push(last);
        head
    },
    <head:(<T> ",")*> <last:T?> if Empty == "MaybeEmpty" => {
        let mut head = head;
        if let Some(last) = last { head.push(last); }
        head
    },
};

ListSep<T, Empty>: Vec<T> = {
    <head:(<T> r"[,;]")*> <last:T> if Empty == "NonEmpty" => {
        let mut head = head;
        head.push(last);
        head
    },
    <head:(<T> r"[,;]")*> <last:T?> if Empty == "MaybeEmpty" => {
        let mut head = head;
        if let Some(last) = last { head.push(last); }
        head
    },
};

/// Parses Lua's "long bracket" and returns the content. A long bracket is opened with '[',
/// followed by any number of '=' (including 0), followed by '[' and is closed with ']', followed
/// by the same number of '=' used in the opening bracket, followed by ']'.
LongBracket: &'input str = {
    // TODO
};

Comment: &'input str = {
    "--" <LongBracket>,
    <c:r"--[^\n]*"> => &c[2..],     // Strip `--`. Hack to prevent ambiguity
};

/// String can be delimited by double or single quotes, or by "long brackets", which allow multiline
/// strings with arbitrary content.
String: &'input str = {
    <r#""(\\.|[^\\"])*""#>,
    <r#"'(\\.|[^\\'])*'"#>,
    <LongBracket>,
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

pub BinOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::NEq,
    "~=" => BinOp::NEqLua,
    ">=" => BinOp::GEq,
    "<=" => BinOp::LEq,
    ">>" => BinOp::ShiftR,
    "<<" => BinOp::ShiftL,
    "<" => BinOp::Less,
    ">" => BinOp::Greater,
    "&&" => BinOp::LAnd,
    "and" => BinOp::LAndLua,
    "||" => BinOp::LOr,
    "or" => BinOp::LOrLua,
    "&" => BinOp::BAnd,
    "~" => BinOp::BXor,
    "|" => BinOp::BOr,
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "^" => BinOp::Pow,
    ".." => BinOp::Concat,
};

pub UnOp: UnOp = {
    "-" => UnOp::Negate,
    "!" => UnOp::LNot,
    "not" => UnOp::LNotLua,
    "~" => UnOp::BNot,
    "#" => UnOp::Len,
};

TableEntry: TableEntry<'input> = {
    <Ident> "=" <Expr>          => TableEntry::IdentPair(<>),
    "[" <Expr> "]" "=" <Expr>   => TableEntry::Pair(<>),
    <Expr>                      => TableEntry::Elem(<>),
};
TableCons = "{" <ListSep<TableEntry, "MaybeEmpty">> r"[,;]"? "}";
ArrayCons = "[" <ListSep<Expr, "MaybeEmpty">> r"[,;]"? "]";

CallArgs: CallArgs<'input> = {
    "(" <Comma<Expr, "MaybeEmpty">> ")" => CallArgs::Normal(<>),
    String => CallArgs::String(<>.to_string()), // FIXME NO COPIES!
    TableCons => CallArgs::Table(<>),
};

// FIXME: Like `Var`, this should be left-recursive
Callee: Expr<'input> = {
    <v:Var> => Spanned::new(v.span, ExprKind::Var(v)),
    "(" <Expr> ")",
};
Call: Call<'input> = {
    <callee:Callee> <name:Ident?> <args:CallArgs+> => {
        let mut it = args.into_iter();
        let first_args = it.next().unwrap();
        let callee_span = callee.span.clone();
        let callee = Box::new(callee);
        let mut what = Spanned::new(callee_span, match name {
            None => Call::Normal(callee, first_args),
            Some(name) => Call::Method(callee, name, first_args),
        });

        for list in it {
            what = Spanned::new(callee_span,
                Call::Normal(Box::new(Spanned::new(what.span, ExprKind::Call(what.value))), list));
        }

        what.value
    }
};

// FIXME `Var` should just be left-recursive
VarIndex: VarIndex<'input> = {
    "." <i:Ident> => VarIndex::DotIndex(i),
    "[" <e:Expr> "]" => VarIndex::ExprIndex(Box::new(e)),
};
pub Var: Spanned<VarKind<'input>> = {
    <i:Ident> <idxs:VarIndex*> => {
        let mut v = Spanned::new(i.span, VarKind::Named(i.value));
        for idx in idxs {
            let start = v.span.start;
            let end = match idx {
                VarIndex::ExprIndex(ref e) => e.span.start + e.span.len,
                VarIndex::DotIndex(ref id) => id.span.start + id.span.len,
            };

            v = mkspanned(VarKind::Indexed(Box::new(v), idx), start, end);
        }

        v
    }
};

ExprKind: ExprKind<'input> = {
    r"[0-9]+" => { loop{} }
};

pub Expr = Spanned<ExprKind>;

StmtKind: StmtKind<'input> = {
    "local" <Comma<Ident, "NonEmpty">> => {
        StmtKind::Decl(<>, Vec::new())
    },
    "local" <Comma<Ident, "NonEmpty">> "=" <Comma<Expr, "NonEmpty">> => {
        StmtKind::Decl(<>)
    },
    <Comma<Var, "NonEmpty">> "=" <Comma<Expr, "NonEmpty">> => {
        StmtKind::Assign(<>)
    },
    "return" <Comma<Expr, "NonEmpty">?> => {
        StmtKind::Return(<>.unwrap_or(Vec::new()))
    },
    ";" => StmtKind::Semi,
    "break" => StmtKind::Break,
    Call => StmtKind::Call(<>),
};

pub Stmt = Spanned<StmtKind>;

pub Block = Spanned<Stmt*>;
