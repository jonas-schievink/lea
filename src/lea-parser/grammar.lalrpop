use std::mem;

use expr_parser::build_tree;
use span::{Span, Spanned, mkspanned};
use op::*;
use parsetree::*;

use lea_core::Const;

grammar["LALR(1)"];

// `remaining_input` is the remaining input string we want to
// tokenize. The defined regexes will be applied to this string.
//
// The lexer can utilize grammar state. This shared state allows us to,
// for example, add comments to a `Vec` when the lexer sees them, and
// add them to crated AST nodes when the parser creates them.
lexer(remaining_input: &'input str) {
    // In here, we can define a list of regular expressions we want to match against. Just like
    // we do now, ambiguous expressions are denied.

    // This matches single-line comments and `continue`s lexing without yielding a token.
    r"//[^\n]*" => continue,

    // Return single tokens easily
    r"0x[0-9a-fA-F]+" => Tok::HexInt(...),

    // Return multiple tokens
    r"two keywords" => [Tok::Two, Tok::Keywords],

    // This matches a raw string/regex literal, or at least the opening part. Since
    // the exact number of `#`s is important, we bind the matched string to `open`.
    open = r#"r#*""# => {
        // Rust action block

        // Scan until we meet a closing string of the same length.
        // FIXME `r""` Regex literals in rust source? Yay/Nay?
        remaining_input.match_indices("\"").find(|(idx, s)| open.len() == close.len() + 1)

        // Problem: Can't `impl Pattern` on stable Rust
        // However, there's `impl<F> Pattern for F where F: FnMut(char) -> bool`, so I think we can
        // make it work with regular expressions.
    }

    // The next line instructs lalrpop to generate its own rules based on the terminals
    // appearing in the grammar below, even though we defined our own Lexer.
    ...

    // NB: There should probably be a lexer rule that
    // skips whitespace instead of doing that implicitly (`\w+` when we have char classes).
    // However, it shouldn't be added when the
    // lexer already contains a rule that would match whitespace (or is this too much magic and we
    // should just not add the whitespace rule when there's a lexer definition? or have a magic
    // dont_drop_whitespace attribute or thingy for this? or only add the rule when `...` is
    // specified?)
}


/// Utility macro that wraps a `T` in a `Spanned<T>`, attaches its span and parses all preceding
/// comments.
#[inline]
Spanned<T>: Spanned<T> = {
    <start:@L> <t:T> <end:@R> => {
        Spanned::new(Span::new(start, end), t)
    }
};

#[inline]
RawIdent = r"[_a-zA-Z][_a-zA-Z0-9]*";

pub Ident: Spanned<&'input str> = Spanned<RawIdent>;

/// List of `T`s, seperated by `,`. No trailing `,` is allowed.
Comma<T, Empty>: Vec<T> = {
    <head:(<T> ",")*> <last:T> if Empty == "NonEmpty" => {
        let mut head = head;
        head.push(last);
        head
    },
    <head:(<T> ",")*> <last:T?> if Empty == "MaybeEmpty" => {
        let mut head = head;
        if let Some(last) = last { head.push(last); }
        head
    },
};

ListSep<T, Empty>: Vec<T> = {
    <head:(<T> r"[,;]")*> <last:T> if Empty == "NonEmpty" => {
        let mut head = head;
        head.push(last);
        head
    },
    <head:(<T> r"[,;]")*> <last:T?> if Empty == "MaybeEmpty" => {
        let mut head = head;
        if let Some(last) = last { head.push(last); }
        head
    },
};

/// Parses Lua's "long bracket" and returns the content. A long bracket is opened with '[',
/// followed by any number of '=' (including 0), followed by '[' and is closed with ']', followed
/// by the same number of '=' used in the opening bracket, followed by ']'.
LongBracket: &'input str = {
    // TODO
};

Comment: &'input str = {
    "--" <LongBracket>,
    <c:r"--[^\n]*"> => &c[2..],     // Strip `--`. Hack to prevent ambiguity
};

/// String can be delimited by double or single quotes, or by "long brackets", which allow multiline
/// strings with arbitrary content.
String: &'input str = {
    <r#""(\\.|[^\\"])*""#>,
    <r#"'(\\.|[^\\'])*'"#>,
    <LongBracket>,
};

Boolean: bool = {
    "true" => true,
    "false" => false,
};

pub BinOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::NEq,
    "~=" => BinOp::NEqLua,
    ">=" => BinOp::GEq,
    "<=" => BinOp::LEq,
    ">>" => BinOp::ShiftR,
    "<<" => BinOp::ShiftL,
    "<" => BinOp::Less,
    ">" => BinOp::Greater,
    "&&" => BinOp::LAnd,
    "and" => BinOp::LAndLua,
    "||" => BinOp::LOr,
    "or" => BinOp::LOrLua,
    "&" => BinOp::BAnd,
    "~" => BinOp::BXor,
    "|" => BinOp::BOr,
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "^" => BinOp::Pow,
    ".." => BinOp::Concat,
};

pub UnOp: UnOp = {
    "-" => UnOp::Negate,
    "!" => UnOp::LNot,
    "not" => UnOp::LNotLua,
    "~" => UnOp::BNot,
    "#" => UnOp::Len,
};

TableEntry: TableEntry<'input> = {
    <Ident> "=" <Expr>          => TableEntry::IdentPair(<>),
    "[" <Expr> "]" "=" <Expr>   => TableEntry::Pair(<>),
    <Expr>                      => TableEntry::Elem(<>),
};
TableCons = "{" <ListSep<TableEntry, "MaybeEmpty">> r"[,;]"? "}";
ArrayCons = "[" <ListSep<Expr, "MaybeEmpty">> r"[,;]"? "]";

CallArgs: CallArgs<'input> = {
    "(" <Comma<Expr, "MaybeEmpty">> ")" => CallArgs::Normal(<>),
    String => CallArgs::String(<>.to_string()), // FIXME NO COPIES!
    TableCons => CallArgs::Table(<>),
};

// FIXME: Like `Var`, this should be left-recursive
Callee: Expr<'input> = {
    <v:Var> => Spanned::new(v.span, ExprKind::Var(v)),
    "(" <Expr> ")",
};
Call: Call<'input> = {
    <callee:Callee> <name:Ident?> <args:CallArgs+> => {
        let mut it = args.into_iter();
        let first_args = it.next().unwrap();
        let callee_span = callee.span.clone();
        let callee = Box::new(callee);
        let mut what = Spanned::new(callee_span, match name {
            None => Call::Normal(callee, first_args),
            Some(name) => Call::Method(callee, name, first_args),
        });

        for list in it {
            what = Spanned::new(callee_span,
                Call::Normal(Box::new(Spanned::new(what.span, ExprKind::Call(what.value))), list));
        }

        what.value
    }
};

// FIXME `Var` should just be left-recursive
VarIndex: VarIndex<'input> = {
    "." <i:Ident> => VarIndex::DotIndex(i),
    "[" <e:Expr> "]" => VarIndex::ExprIndex(Box::new(e)),
};
pub Var: Spanned<VarKind<'input>> = {
    <i:Ident> <idxs:VarIndex*> => {
        let mut v = Spanned::new(i.span, VarKind::Named(i.value));
        for idx in idxs {
            let start = v.span.start;
            let end = match idx {
                VarIndex::ExprIndex(ref e) => e.span.start + e.span.len,
                VarIndex::DotIndex(ref id) => id.span.start + id.span.len,
            };

            v = mkspanned(VarKind::Indexed(Box::new(v), idx), start, end);
        }

        v
    }
};

ExprKind: ExprKind<'input> = {
    r"[0-9]+" => { loop{} }
};

pub Expr = Spanned<ExprKind>;

StmtKind: StmtKind<'input> = {
    "local" <Comma<Ident, "NonEmpty">> => {
        StmtKind::Decl(<>, Vec::new())
    },
    "local" <Comma<Ident, "NonEmpty">> "=" <Comma<Expr, "NonEmpty">> => {
        StmtKind::Decl(<>)
    },
    <Comma<Var, "NonEmpty">> "=" <Comma<Expr, "NonEmpty">> => {
        StmtKind::Assign(<>)
    },
    "return" <Comma<Expr, "NonEmpty">?> => {
        StmtKind::Return(<>.unwrap_or(Vec::new()))
    },
    ";" => StmtKind::Semi,
    "break" => StmtKind::Break,
    Call => StmtKind::Call(<>),
};

pub Stmt = Spanned<StmtKind>;

pub Block = Spanned<Stmt*>;
