//! The Lea Virtual Machine executes Lea byte code generated by the emitter.

// TODO tracing, when GC is possible

use lea_core::opcode::*;
use lea_core::fndata::UpvalDesc;

use mem::{TracedRef, GcStrategy, DefaultGc};
use function::{Function, FunctionProto, Upval};
use Array;
use Table;
use Value;
use error::{VmResult, VmError};
use libfn::LibFnError;

use std::iter;
use std::cmp;
use std::rc::Rc;
use std::cell::Cell;

/// Contains information about a called Lea function.
struct CallInfo {
    /// The function active at this call level
    func: TracedRef<Function>,
    /// The instruction pointer (index into opcode vector)
    ip: usize,
    /// The index in the value stack that contains register 0 of this called function.
    ///
    /// For the main function, this is equal to the number of arguments passed to it (varargs are
    /// copied before the stack frame of the callee).
    bottom: usize,
    /// Dynamic stack top. This is updated any time an instruction that returns a variable number
    /// of results is executed and stores the stack slot of value *after* the last value returned
    /// by the instruction (so `dtop == 0` means that no results were returned).
    ///
    /// Unlike `bottom`, this is a relative index into the value stack and must be offset by adding
    /// `bottom` to it (use `reg_get` and `reg_set` to do this).
    dtop: u8,
    /// Number of varargs stored in the value stack before the stack frame of this call.
    va_count: u8,
    /// Number of return values the caller can accept (minus 1). 0 = any number.
    return_lim: u8,
    /// First (local) slot that a return value should be placed in. If `return_lim` is 1, this
    /// field is ignored.
    return_start: u8,
}

/// A VM context. Holds a garbage collector that manages the program's memory, the stack used for
/// local and temporary variables, the callstack, etc.
#[derive(Default)]
pub struct VM {
    pub gc: DefaultGc,
    /// "VM stack", "value stack" or just stack. Stores the activation of functions in the form of
    /// variables (registers) used by the function.
    pub stack: Vec<Value>,
    /// Call stack
    calls: Vec<CallInfo>,
    /// List of open upvalues, sorted by stack slot (`usize` field)
    open_upvals: Vec<(usize, Rc<Cell<Upval>>)>,

    main: Option<TracedRef<Function>>,
}

impl VM {
    pub fn new() -> VM {
        VM::default()
    }

    /// Starts execution of the program. This may not be called while the VM is already executing
    /// a function.
    ///
    /// Returns when the function returns (or a runtime error occurs).
    pub fn start<F>(&mut self, f: TracedRef<Function>, e: F) -> Option<Vec<Value>>
    where F: FnOnce(&mut VmError) {
        // FIXME When is a nested call okay?
        assert_eq!(self.stack.len(), 0);
        assert_eq!(self.calls.len(), 0);

        self.main = Some(f);
        self.push_call(f, 0, 0, 0);  // `ret_count` and `ret_start` are ignored

        let return_vals = match self.main_loop() {
            Ok(vals) => Some(vals),
            Err(mut error) => {
                e(&mut error);
                None
            }
        };

        self.stack.clear();
        self.calls.clear();
        self.main = None;

        return_vals
    }
}

// Private methods

impl VM {
    /// Creates a `CallInfo` object that describes an activation of the given function and pushes
    /// it onto the callstack.
    ///
    /// This will also extend the value stack by the number of slots specified in the function
    /// prototype.
    ///
    /// Note that `va_count` is only used to fill the `CallInfo`, no arguments are actually passed
    /// to the callee, nor is any stack space reserved.
    fn push_call(&mut self, func: TracedRef<Function>, va_count: u8, ret_count: u8, ret_start: u8) {
        let gc = &mut self.gc;
        let proto = unsafe {
            let proto = gc.get_mut(func).proto;
            gc.get_mut(proto)
        };

        // Ensure we have `proto.stacksize + va_count` slots free after current `dtop` (FIXME)
        // XXX is this optimized right?
        let old_len = self.stack.len();
        self.stack.extend(iter::repeat(Value::Nil).take(proto.stacksize as usize));

        self.calls.push(CallInfo {
            func: func,
            ip: 0,
            bottom: old_len,
            dtop: 0,
            va_count: va_count,
            return_lim: ret_count,
            return_start: ret_start,
        });
    }

    /// Called to return from a called Lea function (*not* from the main function). This pops the
    /// created `CallInfo` off the call stack and restores the value stack accordingly.
    ///
    /// Note that this will not manage any return values (the caller's stack frame is left
    /// untouched).
    ///
    /// This function can not be called when the only active function is the program's main
    /// function.
    fn return_from_call(&mut self) {
        assert!(!self.calls.is_empty());
        if self.calls.len() == 1 {
            panic!("return_from_call called while only main function is active");
        }

        // pop stack frame and passed varargs from value stack
        let frame_sz: u8 = self.cur_proto().stacksize;
        let varargs: u8 = self.cur_call().va_count;
        let old_len: usize = self.stack.len();
        let new_len: usize = old_len.checked_sub(frame_sz as usize + varargs as usize)
            .expect("stack underflow (what?) in `vm.return_from_call`");
        debug_assert!(new_len <= old_len);

        self.stack.truncate(new_len);

        self.calls.pop().unwrap();
    }

    fn cur_call(&self) -> &CallInfo {
        &self.calls[self.calls.len() - 1]
    }

    fn cur_call_mut(&mut self) -> &mut CallInfo {
        let lastidx = self.calls.len() - 1;
        &mut self.calls[lastidx]
    }

    pub fn cur_func(&self) -> &Function {
        unsafe { self.gc.get_ref(self.cur_call().func) }
    }

    /// Gets a reference to the prototype of the currently executing function.
    fn cur_proto(&self) -> &FunctionProto {
        let call = self.cur_call();
        let func = unsafe { self.gc.get_ref(call.func) };

        unsafe { self.gc.get_ref(func.proto) }
    }

    /// Obtains a `TracedRef<Function>` pointing at the main function (root of the call stack).
    /// Will panic when the VM isn't executing a function.
    pub fn main_ref(&self) -> TracedRef<Function> {
        self.main.unwrap()
    }

    /// Fetches the current opcode and increments the instruction pointer by 1
    fn fetch(&mut self) -> Opcode {
        let op = *self.cur_proto().opcodes.get(self.cur_call().ip).unwrap_or_else(|| {
            panic!("ip {} out of range ({} opcodes)", self.cur_call().ip, self.cur_proto().opcodes.len())
        });
        self.cur_call_mut().ip += 1;
        op
    }

    /// Gets the value inside a register as specified in an opcode.
    fn reg_get(&self, reg: u8) -> Value {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize]
    }

    /// Set the value of a register (see `reg_get`).
    fn reg_set(&mut self, reg: u8, val: Value) {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize] = val;
    }

    /// Sets a register. If the register is outside the value stack, the value stack will be
    /// extended (with `nil` if there is a hole).
    fn reg_set_or_extend(&mut self, reg: u8, val: Value) {
        let slot: usize = self.cur_call().bottom + reg as usize;
        if slot >= self.stack.len() {
            let len = self.stack.len();
            self.stack.extend(iter::repeat(Value::Nil).take(len - slot + 1));
        }

        self.stack[slot] = val;
    }

    /// Performs a relative jump
    fn reljump(&mut self, rel: i16) {
        let ip = self.cur_call().ip as isize;
        self.cur_call_mut().ip = (ip + rel as isize) as usize;
    }

    fn fwdjump(&mut self, rel: u16) {
        let ip = self.cur_call().ip as isize;
        self.cur_call_mut().ip = (ip + rel as isize) as usize;
    }

    /// VM main loop. This will start dispatching opcodes of the currently active function (at the
    /// top of the call stack).
    ///
    /// If an error occurs, the main loop is aborted immediately and the error is returned. This
    /// means that no active function is exited. The caller is responsible for handling that case.
    fn main_loop(&mut self) -> VmResult {
        loop {
            let op = self.fetch();

            match op {
                MOV(to, from) => {
                    let val = self.reg_get(from);
                    self.reg_set(to, val);
                }
                LOADK(reg, id) => {
                    let val = self.cur_proto().consts[id as usize];
                    self.reg_set(reg, val);
                }
                LOADNIL(start, cnt) => {
                    // Set R[start] through R[start+count] to `nil`
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::Nil);
                    }
                }
                LOADBOOL(start, cnt, val) => {
                    // Set R[start] through R[start+count] to `val` (true or false)
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::Bool(val));
                    }
                }
                TABLE(reg) => {
                    let tab = self.gc.register_obj(Table::default());
                    self.reg_set(reg, Value::Table(tab));
                }
                ARRAY(reg) => {
                    let arr = self.gc.register_obj(Array::default());
                    self.reg_set(reg, Value::Array(arr));
                }
                FUNC(reg, id) => {
                    let func = {
                        // We have to either copy stuff or borrow VM's fields directly (without
                        // calling a helper function) or borrowck complains
                        let proto = self.cur_proto().child_protos[id as usize];
                        let cur_bottom = self.cur_call().bottom;
                        let open_upvals = &mut self.open_upvals;

                        let last_call = self.calls.len() - 1;
                        let cur_func: &Function = unsafe { self.gc.get_ref(self.calls[last_call].func) };

                        Function::new(&self.gc, proto, |desc| match *desc {
                            UpvalDesc::Local(_) => panic!("`UpvalDesc::Local` encountered by VM"),
                            UpvalDesc::Stack(rel_slot) => {
                                // try to find already created `Rc<Cell<Upval>>` for this slot
                                let abs_slot: usize = cur_bottom + rel_slot as usize;

                                match open_upvals.binary_search_by(|&(s, _)| s.cmp(&abs_slot)) {
                                    Ok(i) => open_upvals[i].1.clone(),
                                    Err(i) => {
                                        let up = Rc::new(Cell::new(Upval::Open(abs_slot)));
                                        open_upvals.insert(i, (abs_slot, up.clone()));
                                        up
                                    }
                                }
                            }
                            UpvalDesc::Upval(id) => {
                                // use current function's upvalue
                                cur_func.upvalues[id].clone()
                            }
                        })
                    };

                    let func_ref = self.gc.register_obj(func);
                    self.reg_set(reg, Value::Closure(func_ref));
                }
                CALL(callee_reg, args, ret_lim) => {
                    let callee: Value = self.reg_get(callee_reg);

                    match callee {
                        Value::Closure(callee) => {
                            // number of fixed params the callee can accept
                            let dest_count: u8;
                            let dest_varargs: bool;

                            // number of args the caller wants to pass
                            let src_count: u8 = if args == 0 {
                                self.cur_call().dtop - callee_reg
                            } else {
                                args - 1
                            };

                            {
                                let callee_ref: &Function = unsafe { self.gc.get_ref(callee) };
                                let proto_ref: &FunctionProto = unsafe {
                                    self.gc.get_ref(callee_ref.proto)
                                };

                                dest_count = proto_ref.params;
                                dest_varargs = proto_ref.varargs;
                            }

                            let fixed_pass: u8 = cmp::min(src_count, dest_count);

                            // args we would like to pass via varargs (if callee accepts it)
                            let var_pass: u8 = if src_count > dest_count && dest_varargs {
                                src_count - dest_count
                            } else {
                                0
                            };

                            if var_pass > 0 {
                                // callee will get varargs
                                // copy `var_pass` args onto the value stack
                                let start_slot = callee_reg + fixed_pass + 1;
                                debug!("passing {} varargs starting at {}", var_pass, start_slot);

                                for i in 0..var_pass {
                                    let slot = start_slot + i;
                                    let arg = self.reg_get(slot);
                                    debug!("va {}: {:?}", i, arg);
                                    self.stack.push(arg);
                                }
                            }

                            // first register containing an argument
                            let fixed_start_abs: usize = self.cur_call().bottom + callee_reg as usize + 1;

                            self.push_call(callee, var_pass, ret_lim, callee_reg);

                            // write args-1 arguments to callee stack slots 0..n
                            // depends on whether callee is varargs
                            if args > 1 {
                                for i in 0..fixed_pass {
                                    debug!(
                                        "CALL: fixed pass {:?} from slot {} (abs {}) to slot {} (abs {})",
                                        self.stack[fixed_start_abs + i as usize],
                                        callee_reg + i + 1,
                                        fixed_start_abs + i as usize,
                                        i,
                                        self.cur_call().bottom + i as usize
                                    );

                                    let arg = self.stack[fixed_start_abs + i as usize];
                                    self.reg_set(i, arg);
                                }
                            }
                        }
                        Value::LibFn(libfn) => {
                            let arg_count: u8 = if args == 0 {
                                self.cur_call().dtop - callee_reg
                            } else {
                                args - 1
                            };

                            let args_start: usize = self.cur_call().bottom + callee_reg as usize + 1;
                            let mut ret = Vec::new();
                            let result = libfn.0(self, args_start, arg_count, &mut |val| {
                                ret.push(val);
                            });

                            match result {
                                Ok(()) => {
                                    // Write return values to `callee_reg..`
                                    let ret_count: u8 = if ret_lim == 0 {
                                        ret.len() as u8
                                    } else {
                                        cmp::min(ret_lim - 1, ret.len() as u8)
                                    };

                                    for i in 0..ret_count {
                                        self.reg_set(callee_reg + i as u8, ret[i as usize]);
                                    }

                                    if ret_lim == 0 {
                                        self.cur_call_mut().dtop = callee_reg + ret_count;
                                    }
                                }
                                Err(LibFnError::Val(v)) => {
                                    // FIXME Returning any value as an error is possible, the VM
                                    // should support that
                                    let mut buf = Vec::new();
                                    unsafe { v.fmt(&mut buf, &self.gc).unwrap() }

                                    return Err(format!("{}", String::from_utf8(buf).unwrap()).into())
                                }
                                Err(LibFnError::String(s)) => {
                                    return Err(s.into())
                                }
                            }
                        }
                        _ => {
                            return Err(format!("attempt to call {}", callee.get_type_name()).into())
                        }
                    }
                }
                RETURN(start, cnt) => {
                    let callee_lim: u8 = if cnt == 0 {
                        debug!("dynamic ret from {} to {} (excl.)", start, self.cur_call().dtop);
                        self.cur_call().dtop
                    } else {
                        debug!("fixed ret from {} to {} (excl.)", start, start + cnt - 1);
                        start + cnt - 1
                    };

                    if self.calls.len() == 1 {
                        // main function exits
                        let ret: Vec<_> = (start..callee_lim).map(|i| self.reg_get(i)).collect();
                        let len = self.stack.len();
                        self.stack.truncate(len - ret.len());
                        self.calls.pop();
                        return Ok(ret)
                    } else {
                        let caller_lim = self.cur_call().return_lim;
                        let func_slot = self.cur_call().return_start;
                        let caller_lim: u8 = if caller_lim == 0 {
                            callee_lim
                        } else {
                            caller_lim - 1
                        };
                        // number of ret vals copied directly
                        let lim: u8 = cmp::min(caller_lim, callee_lim);
                        let caller_info_idx = self.calls.len() - 2;

                        {
                            let caller: &CallInfo = &self.calls[caller_info_idx];
                            debug!("RET caller_lim: {}, callee_lim: {}", caller_lim, callee_lim);

                            // copy `start` to `start + lim` (excl.) into caller's slots
                            for i in 0..lim {
                                let dest: usize = caller.bottom + func_slot as usize + i as usize;
                                debug!("copy slot {} ({:?}) to {}", start + i, self.reg_get(start + i as u8), func_slot + i);
                                self.stack[dest] = self.reg_get(start + i);
                            }

                            // fill with `caller_lim - lim` `nil`s
                            for i in 0..caller_lim - lim {
                                let dest = caller.bottom + func_slot as usize + lim as usize + i as usize;
                                debug!("fill {}", func_slot + lim + i);
                                self.stack[dest] = Value::Nil;
                            }
                        }

                        self.calls[caller_info_idx].dtop = func_slot + lim;  // XXX verify this

                        self.return_from_call();
                    }
                }
                CLOSE(rel_min) => {
                    // close all open upvalues to stack slot `rel_min` and above
                    let abs_min = self.cur_call().bottom + rel_min as usize;

                    let start_idx = match self.open_upvals
                            .binary_search_by(|&(s, _)| s.cmp(&abs_min)) {
                        Ok(i) | Err(i) => i
                    };

                    debug!(
                        "CLOSE({}): closing upvals starting at {}; total upvals: {}; start index: {}",
                        rel_min,
                        abs_min,
                        self.open_upvals.len(),
                        start_idx,
                    );

                    // set all upvalues to closed from `start_idx` onward
                    if start_idx < self.open_upvals.len() {
                        let mut count = 0;
                        for &(_, ref upval) in &self.open_upvals[start_idx..] {
                            debug!("CLOSING {:?}", upval.get());

                            count += 1;
                            let new = match upval.get() {
                                Upval::Open(slot) => Upval::Closed(self.stack[slot]),
                                Upval::Closed(_) => unreachable!(),
                            };

                            upval.set(new);
                        }

                        let old_len = self.open_upvals.len();
                        self.open_upvals.truncate(old_len - count);
                    }
                }
                VARARGS(target, count) => {
                    let va_count: u8 = self.cur_call().va_count;
                    // slot of the first vararg (invalid if `va_count == 0`)
                    let first_va = self.cur_call().bottom - self.cur_call().va_count as usize;

                    if count == 0 {
                        // copy all varargs and update dtop
                        for i in 0..va_count {
                            let val = self.stack[first_va + i as usize];
                            debug!("dyn get va {} -> {}: {:?}", i, target + i, val);
                            self.reg_set_or_extend(target + i, val);
                        }

                        debug!(
                            "VARARGS: setting dtop to {} (fixed top: {}, got {} varargs @ {})",
                            target + va_count,
                            self.cur_proto().stacksize,
                            va_count,
                            target
                        );
                        self.cur_call_mut().dtop = target + va_count;
                    } else {
                        // copy exactly `count` varargs to `target` and following regs, fill with
                        // nil if less varargs were passed

                        // copy this number of varargs to `target` and following regs
                        let copy_varargs: u8 = cmp::min(count, va_count);
                        // these are filled with `nil` and stored at `target + copy_varargs`, ...
                        let fill_varargs: u8 = copy_varargs - count;

                        for i in 0..copy_varargs {
                            let val = self.stack[first_va + i as usize];
                            debug!("fixed get va {} (target slot {}): {:?}",
                                first_va + i as usize,
                                target + i,
                                val
                            );
                            self.reg_set(target + i, val);
                        }

                        for i in 0..fill_varargs {
                            debug!("va fill slot {}", target + copy_varargs + i);
                            self.reg_set(target + copy_varargs + i, Value::Nil);
                        }
                    }
                }
                JMP(rel) => {
                    self.reljump(rel);
                }
                IF(cond, rel) => {
                    if self.reg_get(cond).is_truthy() {
                        self.reljump(rel);
                    }
                }
                IFNOT(cond, rel) => {
                    if !self.reg_get(cond).is_truthy() {
                        self.reljump(rel);
                    }
                }
                FORCHECK(slot, rel) => {
                    let loop_var = self.reg_get(slot);
                    let loop_var_int = match loop_var {
                        Value::Number(val) => val,
                        _ => return Err(format!("invalid type of for loop variable").into()),
                    };
                    let step = match self.reg_get(slot + 1) {
                        Value::Number(val) => val,
                        _ => return Err(format!("invalid type of for loop step").into()),
                    };
                    let limit = match self.reg_get(slot + 2) {
                        Value::Number(val) => val,
                        _ => return Err(format!("invalid type of for loop limit").into()),
                    };

                    if (step >= 0 && loop_var_int > limit) || (step < 0 && loop_var_int < limit) {
                        self.fwdjump(rel);
                    }
                }
                GETUPVAL(reg, up) => {
                    let upval = self.cur_func().upvalues[up as usize].get();
                    debug!("GETUPVAL #{} = {:?}", up, upval);

                    let val = match upval {
                        Upval::Open(slot) => self.stack[slot],
                        Upval::Closed(val) => val,
                    };
                    self.reg_set(reg, val);
                }
                SETUPVAL(up, reg) => {
                    let val = self.reg_get(reg);
                    let upval = self.cur_func().upvalues[up as usize].get();
                    debug!("SETUPVAL #{} to {:?} (was: {:?})", up, val, upval);

                    match upval {
                        Upval::Open(slot) => self.stack[slot] = val,
                        Upval::Closed(_) => self.cur_func().upvalues[up as usize].set(Upval::Closed(val)),
                    };
                }
                GETIDX(a, b, c) => {
                    // R[a] := R[b][R[c]]
                    match (self.reg_get(b), self.reg_get(c)) {
                        (Value::Table(tbl), idx) => {
                            let res: Value = unsafe { self.gc.get_ref(tbl).get(&idx) };
                            self.reg_set(a, res);
                        }
                        // TODO Arrays
                        (b, c) => {
                            return Err(format!("attempt to index {} with {}", b.get_type_name(), c.get_type_name()).into());
                        }
                    }
                }
                SETIDX(a, b, c) => {
                    let c = self.reg_get(c);
                    match (self.reg_get(a), self.reg_get(b)) {
                        (Value::Table(tbl), idx) => {
                            let tbl: &mut Table = unsafe { self.gc.get_mut(tbl) };
                            match tbl.set(idx, c) {
                                Ok(_) => {}
                                Err(()) => {
                                    return Err(format!("attempt to index table with nil").into());
                                }
                            }
                        }
                        // TODO Arrays
                        (a, b) => {
                            return Err(format!("attempt to index {} with {}", a.get_type_name(), b.get_type_name()).into());
                        }
                    }
                },
                ADD(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l + r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to add {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                SUB(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l - r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to subtract {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                MUL(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l * r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to multiply {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                DIV(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l / r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to divide {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                MOD(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l % r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to take the remainder of {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                POW(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l.pow(r)))
                    }
                    (b, c) => {
                        return Err(format!("attempt to exponentiate {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                EQ(a, b, c) => {
                    let b = self.reg_get(b);
                    let c = self.reg_get(c);
                    self.reg_set(a, Value::Bool(b == c));
                },
                NEQ(a, b, c) => {
                    let b = self.reg_get(b);
                    let c = self.reg_get(c);
                    self.reg_set(a, Value::Bool(b != c));
                },
                LEQ(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Bool(l <= r));
                    }
                    (Value::String(l), Value::String(r)) => {
                        let res: bool = {
                            let l: &str = unsafe { &self.gc.get_ref(l) };
                            let r: &str = unsafe { &self.gc.get_ref(r) };

                            l <= r
                        };

                        self.reg_set(a, Value::Bool(res));
                    }
                    (b, c) => {
                        return Err(format!("attempt to compare (<=) {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                GEQ(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Bool(l >= r));
                    }
                    (Value::String(l), Value::String(r)) => {
                        let res: bool = {
                            let l: &str = unsafe { &self.gc.get_ref(l) };
                            let r: &str = unsafe { &self.gc.get_ref(r) };

                            l >= r
                        };

                        self.reg_set(a, Value::Bool(res));
                    }
                    (b, c) => {
                        return Err(format!("attempt to compare (>=) {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                LESS(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Bool(l < r));
                    }
                    (Value::String(l), Value::String(r)) => {
                        let res: bool = {
                            let l: &str = unsafe { &self.gc.get_ref(l) };
                            let r: &str = unsafe { &self.gc.get_ref(r) };

                            l < r
                        };

                        self.reg_set(a, Value::Bool(res));
                    }
                    (b, c) => {
                        return Err(format!("attempt to compare (<) {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                GREATER(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Bool(l > r));
                    }
                    (Value::String(l), Value::String(r)) => {
                        let res: bool = {
                            let l: &str = unsafe { &self.gc.get_ref(l) };
                            let r: &str = unsafe { &self.gc.get_ref(r) };

                            l > r
                        };

                        self.reg_set(a, Value::Bool(res));
                    }
                    (b, c) => {
                        return Err(format!("attempt to compare (>) {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                BAND(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l & r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to calculate the bitwise and of {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                BOR(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l | r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to calculate the bitwise or of {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                BXOR(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l ^ r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to calculate the bitwise xor of {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                SHIFTL(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l << r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to perform a left-shift with {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                SHIFTR(a, b, c) => match (self.reg_get(b), self.reg_get(c)) {
                    (Value::Number(l), Value::Number(r)) => {
                        self.reg_set(a, Value::Number(l >> r))
                    }
                    (b, c) => {
                        return Err(format!("attempt to perform a right-shift with {} and {}", b.get_type_name(), c.get_type_name()).into());
                    }
                },
                CONCAT(a, b, c) => {
                    // FIXME This is wrong!
                    let res: String = match (self.reg_get(b), self.reg_get(c)) {
                        (Value::Number(l), Value::Number(r)) => {
                            format!("{}{}", l, r)
                        }
                        (Value::Number(l), Value::String(r)) => {
                            format!("{}{}", l, unsafe { self.gc.get_ref(r) })
                        }
                        (Value::String(l), Value::Number(r)) => {
                            format!("{}{}", unsafe { self.gc.get_ref(l) }, r)
                        }
                        (Value::String(l), Value::String(r)) => {
                            format!("{}{}", unsafe { self.gc.get_ref(l) }, unsafe { self.gc.get_ref(r) })
                        }
                        (b, c) => {
                            return Err(format!("attempt to concatenate {} and {}", b.get_type_name(), c.get_type_name()).into());
                        }
                    };

                    let gcref = self.gc.intern_str(res);
                    self.reg_set(a, Value::String(gcref));
                },
                NEG(a, b) => match self.reg_get(b) {
                    Value::Number(num) => {
                        self.reg_set(a, Value::Number(-num));
                    }
                    b => {
                        return Err(format!("attempt to negate {}", b.get_type_name()).into());
                    }
                },
                INV(a, b) => match self.reg_get(b) {
                    Value::Number(num) => {
                        self.reg_set(a, Value::Number(!num));
                    }
                    b => {
                        return Err(format!("attempt to invert {}", b.get_type_name()).into());
                    }
                },
                LEN(a, b) => match self.reg_get(b) {
                    Value::String(s) => {
                        let len: i64 = unsafe { self.gc.get_ref(s).len() } as i64;
                        self.reg_set(a, Value::Number(len.into()));
                    }
                    Value::Array(arr) => {
                        let len = unsafe { self.gc.get_ref(arr).len() } as i64;
                        self.reg_set(a, Value::Number(len.into()));
                    }
                    Value::Table(t) => {
                        let len = unsafe { self.gc.get_ref(t).len() } as i64;
                        self.reg_set(a, Value::Number(len.into()));
                    }
                    b => {
                        return Err(format!("attempt to get the length of {}", b.get_type_name()).into());
                    }
                },
                NOT(target, src) => {
                    let truthy = self.reg_get(src).is_truthy();
                    self.reg_set(target, Value::Bool(!truthy));
                }
                INVALID => panic!("invalid opcode at ip={}", self.cur_call().ip),
                DEBUG(slot) => println!(
                    "VM DEBUG slot {} (abs {}): {:?}",
                    slot,
                    self.cur_call().bottom + slot as usize,
                    self.reg_get(slot)
                ),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use mem::GcStrategy;
    use function::{FunctionProto, Function, Upval};
    use value::Value;
    use number::Number;

    use lea_core::fndata::{FnData, UpvalDesc};
    use lea_core::opcode::*;
    use lea_core::Const;

    use std::rc::Rc;
    use std::cell::Cell;

    /// Defines a function. Evaluates to an `FnData` object.
    macro_rules! fndef {
        ( {
            stack: $stack:expr,
            params: $params:expr,
            varargs: $varargs:expr,
            upvals: [ $( $upval:expr ),* ],
            fns: [ $( fn $fndef:tt ),* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {
            FnData {
                stacksize: $stack,
                params: $params,
                varargs: $varargs,
                opcodes: Opcodes(vec![
                    $($ops,)*
                ]),
                consts: vec![ $( $const_val, )* ],
                upvals: vec![ $( $upval, )* ],
                lines: Vec::new(),  // TODO
                source_name: String::new(), // TODO
                child_protos: vec![ $( Box::new(fndef!($fndef)), )* ],
            }
        };
        ( {
            stack: $stack:expr,
            fns: [ $( fn $fndef:tt ),* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {
            fndef!({
                stack: $stack,
                params: 0,
                varargs: false,
                upvals: [],
                fns: [ $( fn $fndef ),* ],
                consts: [ $( $const_val, )* ],
                ops: [ $( $ops, )* ]
            });
        };
    }

    /// Runs a new VM instance with the given main function. Returns a tuple containing the VM and
    /// the `VmResult` returned by `vm.start()` (see `error.rs`).
    macro_rules! run {
        ( $main:tt ) => {{
            run!($main with Value::Nil)
        }};
        ( $main:tt with $env:expr ) => {{
            let main: FnData = fndef!($main);
            let mut vm = VM::new();
            let proto = FunctionProto::from_fndata(main, &mut vm.gc);
            let mut first = true;
            let f = Function::new(&vm.gc, proto, |_| if first {
                first = false;
                Rc::new(Cell::new(Upval::Closed($env)))
            } else {
                Rc::new(Cell::new(Upval::Closed(Value::Nil)))
            });
            let f = vm.gc.register_obj(f);
            let ret = vm.start(f, |e| panic!("{}", e));

            (vm, ret)
        }};
    }

    /// Converts its argument to an expression
    macro_rules! mkexpr {
        ( $e:expr ) => ( $e );
    }

    /// Defines a VM test. A main function definition is run, and the state of the VM compared to
    /// some expected values (in registers, with absolute index).
    macro_rules! test {
        ( $main:tt => [ $( $reg:tt : $val:pat, )* ] ) => {{
            let (vm, _) = run!($main);

            // Compare VM's value stack with expected values
            $(
                let tmp = vm.stack[mkexpr!($reg)];
                match tmp {
                    $val => {},
                    _ => {
                        panic!("unexpected value in stack slot {}: got {:?}, expected {}", $reg, tmp, stringify!($val));
                    }
                }
            )*
        }};
        ( $main:tt => return [ ] ) => {{
            let (_, ret) = run!($main);
            assert!(ret.unwrap().is_empty());
        }};
        ( $main:tt => return [ $($val:pat,)+ ] ) => {{
            let (_, ret) = run!($main);

            let mut retvals = ret.unwrap().into_iter();
            $(
                let tmp = retvals.next().expect("not enough values returned");
                match tmp {
                    $val => {},
                    _ => {
                        panic!("unexpected value returned: got {:?}, expected {}", tmp, stringify!($val));
                    }
                }
            )*
        }};
    }

    #[test]
    fn return_single() {
        test!({
            stack: 1,
            fns: [
                fn {
                    stack: 1,
                    fns: [],
                    consts: [],
                    ops: [
                        LOADBOOL(0,0,true),
                        RETURN(0,2),        // `true`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                CALL(0,1,2),    // call with no args, store 1 return value in reg 0
                RETURN(0,2),
            ]
        } => return [
            Value::Bool(true),
        ]);
    }

    #[test]
    fn return_multi() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    fns: [],
                    consts: [],
                    ops: [
                        LOADBOOL(0,0,true),
                        LOADBOOL(1,0,false),
                        LOADNIL(2,0),
                        RETURN(0,4),        // `true`, `false`, `nil`
                    ]
                }
            ],
            consts: [],
            ops: [
                LOADBOOL(2,1,true), // set 2 and 3 to true value
                FUNC(0,0),
                CALL(0,1,5),    // call with no args, store 4 return values in reg 0-3
                RETURN(0,5),
            ]
        } => return [
            Value::Bool(true),
            Value::Bool(false),
            Value::Nil,
            Value::Nil, // filled on return (only 3 values explicitly returned, but 4 stored)
        ]);
    }

    #[test]
    fn call_args() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    params: 2,
                    varargs: false,
                    upvals: [],
                    fns: [],
                    consts: [],
                    ops: [
                        DEBUG(0),
                        DEBUG(1),
                        NOT(0,0),       // `false` => `true`
                        IFNOT(0,100),
                        NOT(1,1),       // `true` => `false`
                        IF(1,200),
                        NOT(2,2),       // `nil` => `true`
                        IFNOT(2,300),
                        RETURN(0,4),    // `true`, `false`, `true`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                LOADBOOL(1,0,false),
                LOADBOOL(2,1,true),
                CALL(0,4,3),    // call with 3 args (`false`, `true`, `true`, last disposed)
                                // store 2 return values in reg 0 and 1
                RETURN(0,4),
            ]
        } => return [
            Value::Bool(true),
            Value::Bool(false),
            Value::Bool(true),  // left over from before call
        ]);
    }

    #[test]
    fn varargs() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    params: 1,
                    varargs: true,
                    upvals: [],
                    fns: [],
                    consts: [],
                    ops: [
                        NOT(0,0),       // `false` => `true`
                        VARARGS(1,1),   // get 1st vararg (`true`)
                        IFNOT(1,100),
                        NOT(1,1),       // `true` => `false`
                        IF(1,150),
                        VARARGS(2,0),   // get all varargs ([`true`, `true`])
                        IF(1,500),
                        IFNOT(2,200),
                        IFNOT(3,300),
                        NOT(2,3),       // `true` => `false`
                        IF(1,600),
                        RETURN(0,4),    // `true`, `false`, `false`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                LOADBOOL(1,0,false),
                LOADBOOL(2,1,true),
                CALL(0,4,0),    // call with 3 args (`false`, [`true`, `true`] <- varargs)
                                // store all return values in regs 0..
                RETURN(0,0),
            ]
        } => return [
            Value::Bool(true),
            Value::Bool(false),
            Value::Bool(false),
        ]);
    }

    #[test] #[should_panic]
    fn meta() {
        // Make sure the `test!` macro correctly panics when a slot value mismatches

        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [
            Value::Bool(true),
        ]);
    }

    #[test] #[should_panic]
    fn stack_too_small() {
        run!({
            stack: 2,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,2),   // writes 0, 1, 2
                RETURN(0,1),
            ]
        });
    }

    #[test]
    fn simplest() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [
            Value::Nil,
        ]);
    }

    #[test] #[should_panic]
    fn test_ret_panic() {
        // Tests the `test!` macro with return values
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [
            Value::Number(Number::Int(4)),
        ]);
    }

    #[test]
    fn test_ret_main() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => return [ ]);
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [ Value::Nil, ]);
        test!({
            stack: 4,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,3),
                LOADBOOL(2,0,true),
                LOADBOOL(3,0,false),
                RETURN(0,5),
            ]
        } => return [ Value::Nil, Value::Nil, Value::Bool(true), Value::Bool(false), ]);
    }

    #[test]
    fn simple() {
        // Tests simple opcodes (no metamethods, no calls, no dtop)

        test!({
            stack: 8,
            fns: [],
            consts: [
                Const::Int(7),
                Const::Str("test".to_string()),
            ],
            ops: [
                LOADNIL(0,0),
                LOADK(1,0),
                LOADK(2,1),
                TABLE(3),
                ARRAY(4),
                JMP(0),                 // no-op
                LOADBOOL(5,0,true),     // is executed
                JMP(1),
                LOADBOOL(5,0,false),    // skipped

                JMP(1),     // A: Jumps to C
                JMP(1),     // B: Jumps behind C
                JMP(-2),    // C: Jumps to B

                IFNOT(5,100),   // 5 should be `true`
                IF(0,200),      // 0 should be `nil`
                NOT(6,5),       // `false`
                NOT(7,0),       // `true`

                RETURN(0,9),
            ]
        } => return [
            Value::Nil,
            Value::Number(Number::Int(7)),
            Value::String(_),
            Value::Table(_),
            Value::Array(_),
            Value::Bool(true),
            Value::Bool(false),
            Value::Bool(true),
        ]);
    }

    #[test]
    fn upval_open() {
        test!({
            stack: 3,
            params: 0,
            varargs: false,
            upvals: [],
            fns: [
                fn {
                    stack: 3,
                    params: 0,
                    varargs: false,
                    upvals: [ UpvalDesc::Stack(0) ],
                    fns: [
                        fn {
                            stack: 1,
                            params: 0,
                            varargs: false,
                            upvals: [ UpvalDesc::Upval(0) ],
                            fns: [],
                            consts: [],
                            ops: [
                                LOADBOOL(0,0,true),
                                SETUPVAL(0,0),  // `true`
                                RETURN(0,1),
                            ]
                        }
                    ],
                    consts: [],
                    ops: [
                        GETUPVAL(0,0),  // `false`
                        FUNC(1,0),
                        CALL(1,1,1),
                        GETUPVAL(1,0),  // `true`
                        RETURN(0,2),
                    ]
                }
            ],
            consts: [],
            ops: [
                LOADBOOL(0,0,false),
                FUNC(1,0),
                CALL(1,1,2),    // stores `false` in 1
                RETURN(0,3),
            ]
        } => return [
            Value::Bool(true),  // changed by inner function
            Value::Bool(false),
        ]);
    }

    #[test]
    fn upval_close() {
        test!({
            stack: 5,
            params: 0,
            varargs: false,
            upvals: [],
            fns: [
                fn {
                    stack: 1,
                    params: 0,
                    varargs: false,
                    upvals: [ UpvalDesc::Stack(0) ],
                    fns: [],
                    consts: [],
                    ops: [
                        GETUPVAL(0,0),
                        NOT(0,0),   // invert upvalue
                        SETUPVAL(0,0),
                        RETURN(0,1),
                    ]
                }
            ],
            consts: [],
            ops: [
                LOADBOOL(0,0,false),
                FUNC(3,0),
                MOV(4,3),   // Because 3 would be overwritten if we called it
                CALL(4,1,1),
                MOV(1,0),
                CLOSE(0),
                MOV(4,3),
                CALL(4,1,1),
                MOV(2,0),
                RETURN(0,4),
            ]
        } => return [
            Value::Bool(true),  // changed by inner function
            Value::Bool(true),  // not changed, since upvalue is closed
            Value::Bool(true),
        ]);
    }
}
