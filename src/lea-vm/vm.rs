//! # The Lea Virtual Machine
//!
//! The VM executes Lea byte code generated by the emitter.
//!
//! # Calls
//!
//! Calls are recorded as `CallInfo`s inside a vector used as a stack. When a call instruction is
//! executed, the current instruction pointer and stack top is saved in a `CallInfo` struct, along
//! with the called function, and pushed onto the call stack.
//!
//! Then, the stack is extended by the (constant) number of stack slots needed, as stored in the
//! function prototype, and the call arguments are copied to the first slots. Depending on whether
//! a variable number of arguments was passed (as encoded in the call instruction) and whether the
//! callee accepts variable parameters, some of the arguments may be discarded or the stack may be
//! grown dynamically.
//!
//! When executing a return instruction, the current `CallInfo` is popped off the call stack and
//! the instruction pointer is restored. The returned values are then copied into the caller's
//! stack frame (the number - possibly dynamic - is encoded in the call instruction). The VM stack
//! is adjusted by truncating it to a length of `lasttop`, stored in the `CallInfo`.
//!
//! If the call stack is now empty, the main function of the program has just returned and the VM
//! will exit.
//!
//! Otherwise, the topmost `CallInfo` on the call stack is the caller of the function that just
//! returned.

// TODO tracing, when GC is possible

use lea_core::opcode::*;

use mem::{TracedRef, GcStrategy};
use function::{Function, FunctionProto, Upval};
use value::Value;
use error::VmResult;

use std::iter;

/// Contains information about a called Lea function.
pub struct CallInfo {
    /// The function active at this call level
    func: TracedRef<Function>,
    /// The instruction pointer (index)
    ip: usize,
    /// The index in the value stack that contains register 0 of this called function.
    bottom: usize,
    /// Dynamic stack top. This is updated any time an instruction that returns a variable number
    /// of results is executed and stores the stack slot of value *after* the last value returned
    /// by the instruction (so `dtop == 0` means that no results were returned).
    ///
    /// Unlike `bottom`, this is a relative index into the value stack and must be offset by adding
    /// `bottom` to it (use `reg_get` and `reg_set` to do this).
    dtop: u8,
}

/// A VM context. Holds a garbage collector that manages the program's memory, the stack used for
/// local and temporary variables, the callstack, etc.
pub struct VM<G: GcStrategy> {
    gc: G,
    main: TracedRef<Function>,
    /// Call stack
    calls: Vec<CallInfo>,
    /// "VM stack", "value stack" or just stack. Stores the activation of functions in the form of
    /// variables (registers) used by the function.
    stack: Vec<Value>,
}

impl<G: GcStrategy> VM<G> {
    pub fn new(gc: G, main: TracedRef<Function>) -> VM<G> {
        VM {
            gc: gc,
            main: main,
            calls: Vec::new(),
            stack: Vec::new(),
        }
    }

    /// Utility function that takes a main function as a `FunctionProto`, instantiates it and sets
    /// its first upvalue to `env`.
    pub fn with_env(mut gc: G, main: TracedRef<FunctionProto>, env: Value) -> VM<G> {
        // TODO mark this function unsafe?
        let mut first = true;
        let func = Function::new(&mut gc, main, |_| if first {
            first = false;
            Upval::Closed(env)
        } else {
            Upval::Closed(Value::TNil)
        });

        let mainref = gc.register_obj(func);
        VM::new(gc, mainref)
    }

    pub fn gc(&self) -> &G {
        &self.gc
    }

    pub fn gc_mut(&mut self) -> &mut G {
        &mut self.gc
    }

    /// Starts execution of the program. This may not be called multiple times on the same VM.
    ///
    /// Returns when the main function returns (or a runtime error occurs).
    pub fn start(&mut self) -> VmResult {
        // create initial CallInfo and run
        assert!(self.calls.is_empty());
        assert!(self.stack.is_empty());

        let main = self.main;
        self.push_call_to(main);
        self.run()
    }
}

// Private methods

impl<G: GcStrategy> VM<G> {
    /// Creates a `CallInfo` object that describes an activation of the given function and pushes
    /// it onto the callstack.
    ///
    /// This will also extend the value stack by the number of slots specified in the function
    /// prototype.
    fn push_call_to(&mut self, func: TracedRef<Function>) {
        let bottom = if self.calls.is_empty() { 0 } else {
            let call = self.cur_call();
            call.bottom + call.dtop as usize
        };
        let gc = &mut self.gc;
        let proto = unsafe {
            let proto = gc.get_mut(func).proto;
            gc.get_mut(proto)
        };

        // Ensure we have `proto.stacksize` slots free after current `dtop` (FIXME)
        // XXX is this optimized right?
        self.stack.extend(iter::repeat(Value::TNil).take(bottom + proto.stacksize as usize));

        self.calls.push(CallInfo {
            func: func,
            ip: 0,
            bottom: bottom,
            dtop: 0,
        });
    }

    /// Called to return from a called Lea function (*not* from the main function). This pops the
    /// created `CallInfo` off the call stack and restores the value stack accordingly.
    ///
    /// This can not be called when the only active function is the program's main function.
    fn return_from_call(&mut self) {
        if self.calls.len() == 1 {
            panic!("return_from_call called while only main function is active");
        }

        unimplemented!();
    }

    fn cur_call(&self) -> &CallInfo {
        &self.calls[self.calls.len() - 1]
    }

    fn cur_call_mut(&mut self) -> &mut CallInfo {
        let lastidx = self.calls.len() - 1;
        &mut self.calls[lastidx]
    }

    fn cur_proto(&self) -> &FunctionProto {
        let call = self.cur_call();
        let func = unsafe { self.gc().get_ref(call.func) };

        unsafe { self.gc().get_ref(func.proto) }
    }

    /// Fetches the current opcode and increments the instruction pointer by 1
    fn fetch(&mut self) -> Opcode {
        let op = self.cur_proto().opcodes[self.cur_call().ip];
        self.cur_call_mut().ip += 1;
        op
    }

    /// Gets the value inside a register as specified in an opcode.
    fn reg_get(&self, reg: u8) -> Value {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize]
    }

    fn reg_set(&mut self, reg: u8, val: Value) {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize] = val;
    }

    /// VM main loop. This will start dispatching opcodes of the currently active function (at the
    /// top of the call stack).
    fn run(&mut self) -> VmResult {
        loop {
            let op = self.fetch();

            match op {
                MOV(to, from) => {
                    let val = self.reg_get(from);
                    self.reg_set(to, val);
                }
                LOADK(reg, id) => {
                    let val = self.cur_proto().consts[id as usize];
                    self.reg_set(reg, val);
                }
                LOADNIL(start, cnt) => {
                    // Set R[start] through R[start+count] to `nil`
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::TNil);
                    }
                }
                LOADBOOL(start, cnt, val) => {
                    // Set R[start] through R[start+count] to `val` (true or false)
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::TBool(val));
                    }
                }
                RETURN(start, cnt) => {
                    let i = start;
                    let lim = if cnt == 0 {
                        debug!("dynamic ret from {} to {} (excl.)", start, self.cur_call().dtop);
                        self.cur_call().dtop
                    } else {
                        debug!("fixed ret from {} to {} (excl.)", start, cnt-1);
                        cnt-1
                    };

                    if self.calls.len() == 1 {
                        // main function exits
                        return Ok((i..lim).map(|i| self.reg_get(i)).collect())
                    } else {
                        self.return_from_call();
                    }
                }
                _ => panic!("unimplemented opcode: {:?}", op),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use mem::noop::NoopGc;
    use function::FunctionProto;
    use value::Value;

    use lea_core::fndata::FnData;
    use lea_core::opcode::*;
    use lea_core::literal::Literal;


    /// Defines a function. Evaluates to an `FnData` object.
    macro_rules! fndef {
        ( {
            stack: $stack:expr,
            fns: [ $( fn $fndef:tt, )* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {{
            FnData {
                stacksize: $stack,
                params: 0,      // TODO
                varargs: false, // TODO
                opcodes: Opcodes(vec![
                    $($ops,)*
                ]),
                consts: vec![ $( $const_val, )* ],
                upvals: Vec::new(), // TODO
                lines: Vec::new(),  // TODO
                source_name: String::new(), // TODO
                child_protos: vec![ $( Box::new(fndef!($fndef)), )* ],
            }
        }};
    }

    /// Runs a new VM instance with the given main function. Returns a tuple containing the VM and
    /// the `VmResult` returned by `vm.start()` (see `error.rs`).
    macro_rules! run {
        ( $main:tt ) => {{
            run!($main with Value::TNil)
        }};
        ( $main:tt with $env:expr ) => {{
            let main: FnData = fndef!($main);
            let mut gc = NoopGc::default();
            let proto = FunctionProto::from_fndata(main, &mut gc);
            let mut vm = VM::with_env(gc, proto, $env);
            let ret = vm.start();

            (vm, ret)
        }};
    }

    /// FIXME Due to a bug in Rust, `tt` metavariables behave weird when used in an expression
    /// context. This macro fixes this: It can be invoked with a `tt` variable (or any number of
    /// them), parses it as an expression, and expands to that.
    macro_rules! mkexpr {
        ( $e:expr ) => ( $e );
    }

    /// Defines a VM test. A main function definition is run, and the state of the VM compared to
    /// some expected values (in registers, with absolute index).
    macro_rules! test {
        ( $main:tt => [ $( $reg:tt : $val:pat, )* ] ) => {{
            let (vm, _) = run!($main);

            // Compare VM's value stack with expected values
            $(
                let tmp = vm.stack[mkexpr!($reg)];
                match tmp {
                    $val => {},
                    _ => {
                        panic!("Unexpected value in VM stack: Got {:?}, expected something that matches {}", tmp, stringify!($val));
                    }
                }
            )*
        }};
        ( $main:tt => return [ ] ) => {{
            let (_, ret) = run!($main);
            assert!(ret.unwrap().is_empty());
        }};
        ( $main:tt => return [ $($val:pat),+ ] ) => {{
            let (_, ret) = run!($main);

            let mut retvals = ret.unwrap().into_iter();
            $(
                let tmp = retvals.next().expect("not enough values returned");
                match tmp {
                    $val => {},
                    _ => {
                        panic!("Unexpected value returned: Got {:?}, expected something that matches {}", tmp, stringify!($val));
                    }
                }
            )*
        }};
    }

    #[test] #[should_panic]
    fn meta() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
        ]);
    }

    #[test] #[should_panic]
    fn stack_too_small() {
        run!({
            stack: 2,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,2),   // writes 0, 1, 2
                RETURN(0,1),
            ]
        });
    }

    #[test]
    fn simplest() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TNil,
        ]);
    }

    #[test] #[should_panic]
    fn test_ret_panic() {
        // Tests the `test_ret!` macro
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [ Value::TInt(4) ]);
    }

    #[test]
    fn test_ret_main() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => return [ ]);
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [ Value::TNil ]);
        test!({
            stack: 4,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,3),
                LOADBOOL(2,0,true),
                LOADBOOL(3,0,false),
                RETURN(0,5),
            ]
        } => return [ Value::TNil, Value::TNil, Value::TBool(true), Value::TBool(false) ]);
    }

    #[test]
    fn simple() {
        test!({
            stack: 5,
            fns: [],
            consts: [
                Literal::TInt(7),
                Literal::TStr("test".to_string()),
            ],
            ops: [
                LOADNIL(0,0),
                LOADK(1,0),
                LOADK(2,1),
                RETURN(0,1),
            ]
        } => [
            0: Value::TNil,
            1: Value::TInt(7),
            2: Value::TStr(_),
        ]);
    }
}
