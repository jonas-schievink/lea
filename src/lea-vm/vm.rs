//! # The Lea Virtual Machine
//!
//! The VM executes Lea byte code generated by the emitter.
//!
//! # Calls
//!
//! Calls are recorded as `CallInfo`s inside a vector used as a stack. When a call instruction is
//! executed, the current instruction pointer and stack top is saved in a `CallInfo` struct, along
//! with the called function, and pushed onto the call stack.
//!
//! Then, the stack is extended by the (constant) number of stack slots needed, as stored in the
//! function prototype, and the call arguments are copied to the first slots. Depending on whether
//! a variable number of arguments was passed (as encoded in the call instruction) and whether the
//! callee accepts variable parameters, some of the arguments may be discarded or the stack may be
//! grown dynamically.
//!
//! When executing a return instruction, the current `CallInfo` is popped off the call stack and
//! the instruction pointer is restored. The returned values are then copied into the caller's
//! stack frame (the number - possibly dynamic - is encoded in the call instruction). The VM stack
//! is adjusted by truncating it to a length of `lasttop`, stored in the `CallInfo`.
//!
//! If the call stack is now empty, the main function of the program has just returned and the VM
//! will exit.
//!
//! Otherwise, the topmost `CallInfo` on the call stack is the caller of the function that just
//! returned.

// TODO tracing, when GC is possible

use lea_core::opcode::*;

use mem::{TracedRef, GcStrategy};
use function::{Function, FunctionProto, Upval};
use value::Value;
use error::VmResult;

use std::iter;

/// Contains information about a called Lea function.
pub struct CallInfo {
    /// The function active at this call level
    func: TracedRef<Function>,
    /// The instruction pointer (index)
    ip: usize,
    /// The index in the value stack that contains register 0 of this called function.
    bottom: usize,
    /// Dynamic stack top. This is updated any time an instruction that returns a variable number
    /// of results is executed and stores the stack slot of value *after* the last value returned
    /// by the instruction (so `dtop == 0` means that no results were returned).
    ///
    /// Unlike `bottom`, this is a relative index into the value stack and must be offset by adding
    /// `bottom` to it (use `reg_get` and `reg_set` to do this).
    dtop: u8,
}

/// A VM context. Holds a garbage collector that manages the program's memory, the stack used for
/// local and temporary variables, the callstack, etc.
pub struct VM<G: GcStrategy> {
    gc: G,
    main: TracedRef<Function>,
    /// Call stack
    calls: Vec<CallInfo>,
    /// "VM stack", "value stack" or just stack. Stores the activation of functions in the form of
    /// variables (registers) used by the function.
    stack: Vec<Value>,
}

impl<G: GcStrategy> VM<G> {
    pub fn new(gc: G, main: TracedRef<Function>) -> VM<G> {
        VM {
            gc: gc,
            main: main,
            calls: Vec::new(),
            stack: Vec::new(),
        }
    }

    /// Utility function that takes a main function as a `FunctionProto`, instantiates it and sets
    /// its first upvalue to `env`.
    pub fn with_env(mut gc: G, main: TracedRef<FunctionProto>, env: Value) -> VM<G> {
        // TODO mark this function unsafe?
        let mut first = true;
        let func = Function::new(&mut gc, main, |_| if first {
            first = false;
            Upval::Closed(env)
        } else {
            Upval::Closed(Value::TNil)
        });

        let mainref = gc.register_obj(func);
        VM::new(gc, mainref)
    }

    pub fn gc(&self) -> &G {
        &self.gc
    }

    pub fn gc_mut(&mut self) -> &mut G {
        &mut self.gc
    }

    /// Starts execution of the program. This may not be called multiple times on the same VM.
    ///
    /// Returns when the main function returns (or a runtime error occurs).
    pub fn start(&mut self) -> VmResult {
        // create initial CallInfo and run
        assert!(self.calls.is_empty());
        assert!(self.stack.is_empty());

        let main = self.main;
        self.push_call_to(main);
        self.run()
    }
}

// Private methods

impl<G: GcStrategy> VM<G> {
    /// Creates a `CallInfo` object that describes an activation of the given function and pushes
    /// it onto the callstack.
    ///
    /// This will also extend the value stack by the number of slots specified in the function
    /// prototype.
    fn push_call_to(&mut self, func: TracedRef<Function>) {
        let bottom = if self.calls.is_empty() { 0 } else {
            let call = self.cur_call();
            call.bottom + call.dtop as usize
        };
        let gc = &mut self.gc;
        let proto = unsafe {
            let proto = gc.get_mut(func).proto;
            gc.get_mut(proto)
        };

        // Ensure we have `proto.stacksize` slots free after current `dtop` (FIXME)
        // XXX is this optimized right?
        self.stack.extend(iter::repeat(Value::TNil).take(bottom + proto.stacksize as usize));

        self.calls.push(CallInfo {
            func: func,
            ip: 0,
            bottom: bottom,
            dtop: 0,
        });
    }

    fn cur_call(&self) -> &CallInfo {
        &self.calls[self.calls.len() - 1]
    }

    fn cur_call_mut(&mut self) -> &mut CallInfo {
        let lastidx = self.calls.len() - 1;
        &mut self.calls[lastidx]
    }

    fn cur_proto(&self) -> &FunctionProto {
        let call = self.cur_call();
        let func = unsafe { self.gc().get_ref(call.func) };

        unsafe { self.gc().get_ref(func.proto) }
    }

    /// Fetches the current opcode and increments the instruction pointer by 1
    fn fetch(&mut self) -> Opcode {
        let op = self.cur_proto().opcodes[self.cur_call().ip];
        self.cur_call_mut().ip += 1;
        op
    }

    /// Gets the value inside a register as specified in an opcode.
    fn reg_get(&self, reg: u8) -> Value {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize]
    }

    fn reg_set(&mut self, reg: u8, val: Value) {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize] = val;
    }

    /// VM main loop. This will start dispatching opcodes of the currently active function (at the
    /// top of the call stack).
    fn run(&mut self) -> VmResult {
        loop {
            let op = self.fetch();

            match op {
                LOADNIL(start, cnt) => {
                    // Set R[start] through R[start+count] to `nil`
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::TNil);
                    }
                }
                MOV(to, from) => {
                    let val = self.reg_get(from);
                    self.reg_set(to, val);
                }
                RETURN(start, cnt) => {
                    let i = start;
                    let lim = if cnt == 0 {
                        debug!("dynamic ret from {} to {} (excl.)", start, self.cur_call().dtop);
                        self.cur_call().dtop
                    } else {
                        debug!("fixed ret from {} to {} (excl.)", start, cnt-1);
                        cnt-1
                    };

                    if self.calls.len() == 1 {
                        // main function exits
                        return Ok((i..lim).map(|i| self.reg_get(i)).collect())
                    } else {
                        unimplemented!();
                    }
                }
                _ => panic!("unimplemented opcode: {:?}", op),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use mem::noop::NoopGc;
    use function::FunctionProto;
    use value::Value;

    use lea_core::fndata::FnData;
    use lea_core::opcode::*;


    /// Defines a function. Evaluates to an `FnData` object.
    macro_rules! fndef {
        ( {
            stack: $stack:expr,
            fns: [ $( fn $fndef:tt, )* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {{
            FnData {
                stacksize: $stack,
                params: 0,      // TODO
                varargs: false, // TODO
                opcodes: Opcodes(vec![
                    $($ops,)*
                ]),
                consts: vec![ $( $const_val, )* ],
                upvals: Vec::new(), // TODO
                lines: Vec::new(),  // TODO
                source_name: String::new(), // TODO
                child_protos: vec![ $( Box::new(fndef!($fndef)), )* ],
            }
        }};
    }

    /// Defines a VM test. A main function definition is run, and the state of the VM compared to
    /// some expected values (in registers, with absolute index).
    macro_rules! test {
        ( $main:tt => [ $( $reg:tt : $val:expr, )* ] ) => {{
            let main: FnData = fndef!($main);
            let mut gc = NoopGc::default();
            let proto = FunctionProto::from_fndata(main, &mut gc);
            let mut vm = VM::with_env(gc, proto, Value::TNil);  // TODO
            vm.start().unwrap();

            // Compare VM's value stack with expected values
            $( assert_eq!(vm.stack[$reg], $val); )*
        }};
    }

    #[test] #[should_panic]
    fn meta() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
        ]);
    }

    #[test]
    fn simplest() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TNil,
        ]);
    }
}
