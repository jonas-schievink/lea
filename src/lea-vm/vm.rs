//! # The Lea Virtual Machine
//!
//! The VM executes Lea byte code generated by the emitter.
//!
//! # Calls
//!
//! Calls are recorded as `CallInfo`s inside a vector used as a stack. When a call instruction is
//! executed, the current instruction pointer and stack top is saved in a `CallInfo` struct, along
//! with the called function, and pushed onto the call stack.
//!
//! The VM will then push all arguments passed as varargs onto the stack
//!
//! Then, the stack is extended by the (constant) number of stack slots needed, as stored in the
//! function prototype, and the fixed call arguments are copied to the first slots.
//!
//! When executing a return instruction, the current `CallInfo` is popped off the call stack and
//! the instruction pointer is restored. The returned values are then copied into the caller's
//! stack frame (the number - possibly dynamic - is encoded in the call instruction). The VM stack
//! is adjusted by truncating it to a length of `lasttop`, stored in the `CallInfo`.
//!
//! If the call stack is now empty, the main function of the program has just returned and the VM
//! will exit.
//!
//! Otherwise, the topmost `CallInfo` on the call stack is the caller of the function that just
//! returned.

// TODO tracing, when GC is possible

use lea_core::opcode::*;
use lea_core::fndata::UpvalDesc;

use mem::{TracedRef, GcStrategy};
use function::{Function, FunctionProto, Upval};
use array::Array;
use table::Table;
use value::Value;
use error::VmResult;

use std::cmp;

/// Contains information about a called Lea function.
pub struct CallInfo {
    /// The function active at this call level
    func: TracedRef<Function>,
    /// The instruction pointer (index into opcode vector)
    ip: usize,
    /// The index in the value stack that contains register 0 of this called function.
    ///
    /// For the main function, this is equal to the number of arguments passed to it (varargs are
    /// copied before the stack frame of the callee).
    bottom: usize,
    /// Dynamic stack top. This is updated any time an instruction that returns a variable number
    /// of results is executed and stores the stack slot of value *after* the last value returned
    /// by the instruction (so `dtop == 0` means that no results were returned).
    ///
    /// Unlike `bottom`, this is a relative index into the value stack and must be offset by adding
    /// `bottom` to it (use `reg_get` and `reg_set` to do this).
    dtop: u8,
    /// Number of varargs stored in the value stack before the stack frame of this call.
    va_count: u8,
}

/// A VM context. Holds a garbage collector that manages the program's memory, the stack used for
/// local and temporary variables, the callstack, etc.
pub struct VM<G: GcStrategy> {
    gc: G,
    main: TracedRef<Function>,
    /// Call stack
    calls: Vec<CallInfo>,
    /// "VM stack", "value stack" or just stack. Stores the activation of functions in the form of
    /// variables (registers) used by the function.
    stack: Vec<Value>,
}

impl<G: GcStrategy> VM<G> {
    pub fn new(gc: G, main: TracedRef<Function>) -> VM<G> {
        VM {
            gc: gc,
            main: main,
            calls: Vec::new(),
            stack: Vec::new(),
        }
    }

    /// Utility function that takes a main function as a `FunctionProto`, instantiates it and sets
    /// its first upvalue to `env`.
    pub fn with_env(mut gc: G, main: TracedRef<FunctionProto>, env: Value) -> VM<G> {
        // TODO mark this function unsafe?
        let mut first = true;
        let func = Function::new(&mut gc, main, |_| if first {
            first = false;
            Upval::Closed(env)
        } else {
            Upval::Closed(Value::TNil)
        });

        let mainref = gc.register_obj(func);
        VM::new(gc, mainref)
    }

    pub fn gc(&self) -> &G {
        &self.gc
    }

    pub fn gc_mut(&mut self) -> &mut G {
        &mut self.gc
    }

    /// Starts execution of the program. This may not be called multiple times on the same VM.
    ///
    /// Returns when the main function returns (or a runtime error occurs).
    pub fn start(&mut self) -> VmResult {
        // create initial CallInfo and run
        assert!(self.calls.is_empty());
        assert!(self.stack.is_empty());

        let main = self.main;
        self.push_call(main);
        self.run()
    }
}

// Private methods

impl<G: GcStrategy> VM<G> {
    /// Creates a `CallInfo` object that describes an activation of the given function and pushes
    /// it onto the callstack.
    ///
    /// This will also extend the value stack by the number of slots specified in the function
    /// prototype.
    fn push_call(&mut self, func: TracedRef<Function>) {
        self.push_call_with_varargs(func, 0)
    }

    /// Creates a `CallInfo` object that describes an activation of the given function and pushes
    /// it onto the callstack.
    ///
    /// This will also extend the value stack by the number of slots specified in the function
    /// prototype.
    ///
    /// Note that `va_count` is only used to fill the `CallInfo`, no arguments are actually passed
    /// to the callee, nor is any stack space reserved.
    fn push_call_with_varargs(&mut self, func: TracedRef<Function>, va_count: u8)  {
        let gc = &mut self.gc;
        let proto = unsafe {
            let proto = gc.get_mut(func).proto;
            gc.get_mut(proto)
        };

        // Ensure we have `proto.stacksize + va_count` slots free after current `dtop` (FIXME)
        // XXX is this optimized right?
        let old_len = self.stack.len();
        self.stack.resize(old_len + proto.stacksize as usize, Value::TNil);

        self.calls.push(CallInfo {
            func: func,
            ip: 0,
            bottom: old_len,
            dtop: 0,
            va_count: va_count,
        });
    }

    /// Called to return from a called Lea function (*not* from the main function). This pops the
    /// created `CallInfo` off the call stack and restores the value stack accordingly.
    ///
    /// Note that this will not manage any return values (the caller's stack frame is left
    /// untouched).
    ///
    /// This function can not be called when the only active function is the program's main
    /// function.
    fn return_from_call(&mut self) {
        assert!(!self.calls.is_empty());
        if self.calls.len() == 1 {
            panic!("return_from_call called while only main function is active");
        }

        // pop stack frame and passed varargs from value stack
        let frame_sz: u8 = self.cur_proto().stacksize;
        let varargs: u8 = self.cur_call().va_count;
        let old_len: usize = self.stack.len();
        let new_len: usize = old_len.checked_sub(frame_sz as usize + varargs as usize)
            .expect("stack underflow (what?) in `vm.return_from_call`");
        debug_assert!(new_len <= old_len);

        self.stack.truncate(new_len);

        self.calls.pop().unwrap();
    }

    fn cur_call(&self) -> &CallInfo {
        &self.calls[self.calls.len() - 1]
    }

    fn cur_call_mut(&mut self) -> &mut CallInfo {
        let lastidx = self.calls.len() - 1;
        &mut self.calls[lastidx]
    }

    /// Gets a reference to the prototype of the currently executing function.
    fn cur_proto(&self) -> &FunctionProto {
        let call = self.cur_call();
        let func = unsafe { self.gc().get_ref(call.func) };

        unsafe { self.gc().get_ref(func.proto) }
    }

    /// Fetches the current opcode and increments the instruction pointer by 1
    fn fetch(&mut self) -> Opcode {
        let op = self.cur_proto().opcodes[self.cur_call().ip];
        self.cur_call_mut().ip += 1;
        op
    }

    /// Gets the value inside a register as specified in an opcode.
    fn reg_get(&self, reg: u8) -> Value {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize]
    }

    /// Set the value of a register (see `reg_get`).
    fn reg_set(&mut self, reg: u8, val: Value) {
        let bottom = self.cur_call().bottom;

        self.stack[bottom + reg as usize] = val;
    }

    /// Sets a register. If the register is outside the value stack, the value stack will be
    /// extended (with `nil` if there is a hole).
    fn reg_set_or_extend(&mut self, reg: u8, val: Value) {
        let slot: usize = self.cur_call().bottom + reg as usize;
        if slot >= self.stack.len() {
            self.stack.resize(slot + 1, Value::TNil);
        }

        self.stack[slot] = val;
    }

    /// Performs a relative jump
    fn reljump(&mut self, rel: i16) {
        let ip = self.cur_call().ip as isize;
        self.cur_call_mut().ip = (ip + rel as isize) as usize;
    }

    /// VM main loop. This will start dispatching opcodes of the currently active function (at the
    /// top of the call stack).
    fn run(&mut self) -> VmResult {
        loop {
            let op = self.fetch();

            match op {
                MOV(to, from) => {
                    let val = self.reg_get(from);
                    self.reg_set(to, val);
                }
                LOADK(reg, id) => {
                    let val = self.cur_proto().consts[id as usize];
                    self.reg_set(reg, val);
                }
                LOADNIL(start, cnt) => {
                    // Set R[start] through R[start+count] to `nil`
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::TNil);
                    }
                }
                LOADBOOL(start, cnt, val) => {
                    // Set R[start] through R[start+count] to `val` (true or false)
                    for i in start..start+cnt+1 {
                        self.reg_set(i, Value::TBool(val));
                    }
                }
                TABLE(reg) => {
                    let tab = self.gc.register_obj(Table::default());
                    self.reg_set(reg, Value::TTable(tab));
                }
                ARRAY(reg) => {
                    let arr = self.gc.register_obj(Array::default());
                    self.reg_set(reg, Value::TArray(arr));
                }
                FUNC(reg, id) => {
                    let proto = self.cur_proto().child_protos[id as usize];

                    let func = Function::new(&mut self.gc, proto, |desc| match *desc {
                        UpvalDesc::Local(_) => panic!("`UpvalDesc::Local` encountered by VM"),
                        UpvalDesc::Stack(slot) => {
                            Upval::Open(slot as usize)
                        }
                        UpvalDesc::Upval(id) => {
                            Upval::Open(id)
                        }
                    });

                    let func_ref = self.gc.register_obj(func);
                    self.reg_set(reg, Value::TFunc(func_ref));
                }
                CALL(callee_reg, args, _) => {  // return count is only used on return
                    let callee: Value = self.reg_get(callee_reg);

                    match callee {
                        Value::TFunc(callee) => {
                            // number of fixed params the callee can accept
                            let dest_count: u8;
                            let dest_varargs: bool;

                            // number of args the caller wants to pass
                            let src_count: u8 = if args == 0 {
                                self.cur_call().dtop - callee_reg
                            } else {
                                args - 1
                            };

                            {
                                let callee_ref: &Function = unsafe { self.gc.get_ref(callee) };
                                let proto_ref: &FunctionProto = unsafe {
                                    self.gc.get_ref(callee_ref.proto)
                                };

                                dest_count = proto_ref.params;
                                dest_varargs = proto_ref.varargs;
                            }

                            let fixed_pass: u8 = cmp::min(src_count, dest_count);

                            // args we would like to pass via varargs (if callee accepts it)
                            let var_pass: u8 = if src_count > dest_count && dest_varargs {
                                src_count - dest_count
                            } else {
                                0
                            };

                            if var_pass > 0 {
                                // callee will get varargs
                                // copy `var_pass` args onto the value stack
                                let start_slot = callee_reg + fixed_pass + 1;
                                println!("passing {} varargs starting at {}", var_pass, start_slot);

                                for i in 0..var_pass {
                                    let slot = start_slot + i;
                                    let arg = self.reg_get(slot);
                                    println!("va {}: {:?}", i, arg);
                                    self.stack.push(arg);
                                }
                            }

                            // first register containing an argument
                            let fixed_start_abs: usize = self.cur_call().bottom + callee_reg as usize + 1;

                            self.push_call_with_varargs(callee, var_pass);

                            // write args-1 arguments to callee stack slots 0..n
                            // depends on whether callee is varargs
                            if args > 1 {
                                for i in 0..fixed_pass {
                                    println!("CALL: fixed pass {:?} from slot {} (abs {}) to slot {} (abs {})", self.stack[fixed_start_abs + i as usize], callee_reg + i + 1, fixed_start_abs + i as usize, i, self.cur_call().bottom + i as usize);
                                    let arg = self.stack[fixed_start_abs + i as usize];
                                    self.reg_set(i, arg);
                                }
                            }
                        }
                        Value::TTable(_) => panic!("metacall not yet implemented"),
                        _ => {
                            return Err(format!("attempt to call {}", callee.get_type_name()).into())
                        }
                    }
                }
                RETURN(start, cnt) => {
                    let callee_lim: u8 = if cnt == 0 {
                        println!("dynamic ret from {} to {} (excl.)", start, self.cur_call().dtop);
                        self.cur_call().dtop
                    } else {
                        println!("fixed ret from {} to {} (excl.)", start, cnt - 1);
                        cnt - 1
                    };

                    if self.calls.len() == 1 {
                        // main function exits
                        return Ok((start..callee_lim).map(|i| self.reg_get(i)).collect())
                    } else {
                        {
                            // How many return values can the caller accept? This is encoded in the
                            // `CALL` instruction, so we need to look it up, first.
                            let caller: &CallInfo = &self.calls[self.calls.len() - 2];
                            let call_ip = caller.ip - 1;
                            let func: &Function = unsafe { self.gc.get_ref(caller.func) };
                            let proto: &FunctionProto = unsafe { self.gc.get_ref(func.proto) };
                            // (I really wish we had less indirections for this sort of stuff)

                            let call_op = proto.opcodes[call_ip];
                            match call_op {
                                CALL(func_slot, _, ret) => {
                                    let caller_lim: u8 = if ret == 0 {
                                        callee_lim
                                    } else {
                                        ret - 1
                                    };

                                    println!("RET caller_lim: {}, callee_lim: {}", caller_lim, callee_lim);

                                    // number of ret vals copied directly
                                    let lim: u8 = cmp::min(caller_lim, callee_lim);

                                    // copy `start` to `start + lim` (excl.) into caller's slots
                                    for i in 0..lim {
                                        let dest: usize = caller.bottom + func_slot as usize + i as usize;
                                        println!("copy slot {} ({:?}) to {}", start + i, self.reg_get(start + i as u8), func_slot + i);
                                        self.stack[dest] = self.reg_get(start + i);
                                    }

                                    // fill with `caller_lim - lim` `nil`s
                                    for i in 0..caller_lim - lim {
                                        let dest = caller.bottom + func_slot as usize + lim as usize + i as usize;
                                        println!("fill {}", func_slot + lim + i);
                                        self.stack[dest] = Value::TNil;
                                    }
                                }
                                _ => {
                                    panic!("couldn't find `CALL` instruction for return (got {:?} at ip = {})", call_op, call_ip);
                                }
                            }
                        }

                        self.return_from_call();
                    }
                }
                //CLOSE
                VARARGS(target, count) => {
                    let va_count: u8 = self.cur_call().va_count;
                    // slot of the first vararg (invalid if `va_count == 0`)
                    let first_va = self.cur_call().bottom - self.cur_call().va_count as usize;

                    if count == 0 {
                        // copy all varargs and update dtop
                        for i in 0..va_count {
                            let val = self.stack[first_va + i as usize];
                            println!("dyn get va {} -> {}: {:?}", i, target + i, val);
                            self.reg_set_or_extend(target + i, val);
                        }

                        println!("VARARGS: setting dtop to {} (fixed top: {}, got {} varargs @ {})", target + va_count, self.cur_proto().stacksize, va_count, target);
                        self.cur_call_mut().dtop = target + va_count;
                    } else {
                        // copy exactly `count` varargs to `target` and following regs, fill with
                        // nil if less varargs were passed

                        // copy this number of varargs to `target` and following regs
                        let copy_varargs: u8 = cmp::min(count, va_count);
                        // these are filled with `nil` and stored at `target + copy_varargs`, ...
                        let fill_varargs: u8 = copy_varargs - count;

                        for i in 0..copy_varargs {
                            let val = self.stack[first_va + i as usize];
                            println!("fixed get va {} (target slot {}): {:?}", first_va + i as usize, target + i, val);
                            self.reg_set(target + i, val);
                        }

                        for i in 0..fill_varargs {
                            println!("va fill slot {}", target + copy_varargs + i);
                            self.reg_set(target + copy_varargs + i, Value::TNil);
                        }
                    }
                }
                JMP(rel) => {
                    self.reljump(rel);
                }
                IF(cond, rel) => {
                    if self.reg_get(cond).is_truthy() {
                        self.reljump(rel);
                    }
                }
                IFNOT(cond, rel) => {
                    if !self.reg_get(cond).is_truthy() {
                        self.reljump(rel);
                    }
                }
                //...
                NOT(target, src) => {
                    let truthy = self.reg_get(src).is_truthy();
                    self.reg_set(target, Value::TBool(!truthy));
                }
                INVALID => panic!("invalid opcode at ip={}", self.cur_call().ip),
                DEBUG(slot) => println!("VM DEBUG slot {} (abs {}): {:?}", slot, self.cur_call().bottom + slot as usize, self.reg_get(slot)),
                _ => panic!("unimplemented opcode: {:?}", op),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use mem::noop::NoopGc;
    use function::FunctionProto;
    use value::Value;

    use lea_core::fndata::FnData;
    use lea_core::opcode::*;
    use lea_core::literal::Literal;


    /// Defines a function. Evaluates to an `FnData` object.
    macro_rules! fndef {
        ( {
            stack: $stack:expr,
            params: $params:expr,
            varargs: $varargs:expr,
            fns: [ $( fn $fndef:tt ),* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {
            FnData {
                stacksize: $stack,
                params: $params,
                varargs: $varargs,
                opcodes: Opcodes(vec![
                    $($ops,)*
                ]),
                consts: vec![ $( $const_val, )* ],
                upvals: Vec::new(), // TODO
                lines: Vec::new(),  // TODO
                source_name: String::new(), // TODO
                child_protos: vec![ $( Box::new(fndef!($fndef)), )* ],
            }
        };
        ( {
            stack: $stack:expr,
            fns: [ $( fn $fndef:tt ),* ],
            consts: [ $( $const_val:expr, )* ],
            ops: [ $( $ops:expr, )* ]
        } ) => {
            fndef!({
                stack: $stack,
                params: 0,
                varargs: false,
                fns: [ $( fn $fndef ),* ],
                consts: [ $( $const_val, )* ],
                ops: [ $( $ops, )* ]
            });
        };
    }

    /// Runs a new VM instance with the given main function. Returns a tuple containing the VM and
    /// the `VmResult` returned by `vm.start()` (see `error.rs`).
    macro_rules! run {
        ( $main:tt ) => {{
            run!($main with Value::TNil)
        }};
        ( $main:tt with $env:expr ) => {{
            let main: FnData = fndef!($main);
            let mut gc = NoopGc::default();
            let proto = FunctionProto::from_fndata(main, &mut gc);
            let mut vm = VM::with_env(gc, proto, $env);
            let ret = vm.start();

            (vm, ret)
        }};
    }

    /// FIXME Due to a bug in Rust, `tt` metavariables behave weird when used in an expression
    /// context. This macro fixes this: It can be invoked with a `tt` variable (or any number of
    /// them), parses it as an expression, and expands to that.
    macro_rules! mkexpr {
        ( $e:expr ) => ( $e );
    }

    /// Defines a VM test. A main function definition is run, and the state of the VM compared to
    /// some expected values (in registers, with absolute index).
    macro_rules! test {
        ( $main:tt => [ $( $reg:tt : $val:pat, )* ] ) => {{
            let (vm, _) = run!($main);

            // Compare VM's value stack with expected values
            $(
                let tmp = vm.stack[mkexpr!($reg)];
                match tmp {
                    $val => {},
                    _ => {
                        panic!("unexpected value in stack slot {}: got {:?}, expected {}", $reg, tmp, stringify!($val));
                    }
                }
            )*
        }};
        ( $main:tt => return [ ] ) => {{
            let (_, ret) = run!($main);
            assert!(ret.unwrap().is_empty());
        }};
        ( $main:tt => return [ $($val:pat),+ ] ) => {{
            let (_, ret) = run!($main);

            let mut retvals = ret.unwrap().into_iter();
            $(
                let tmp = retvals.next().expect("not enough values returned");
                match tmp {
                    $val => {},
                    _ => {
                        panic!("unexpected value returned: got {:?}, expected {}", tmp, stringify!($val));
                    }
                }
            )*
        }};
    }

    #[test]
    fn return_single() {
        test!({
            stack: 1,
            fns: [
                fn {
                    stack: 1,
                    fns: [],
                    consts: [],
                    ops: [
                        LOADBOOL(0,0,true),
                        RETURN(0,2),        // `true`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                CALL(0,1,2),    // call with no args, store 1 return value in reg 0
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),  // returned from caller
        ]);
    }

    #[test]
    fn return_multi() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    fns: [],
                    consts: [],
                    ops: [
                        LOADBOOL(0,0,true),
                        LOADBOOL(1,0,false),
                        LOADNIL(2,0),
                        RETURN(0,4),        // `true`, `false`, `nil`
                    ]
                }
            ],
            consts: [],
            ops: [
                LOADBOOL(2,1,true), // set 2 and 3 to true value
                FUNC(0,0),
                CALL(0,1,5),    // call with no args, store 4 return values in reg 0-3
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
            1: Value::TBool(false),
            2: Value::TNil,
            3: Value::TNil, // filled on return (only 3 values explicitly returned, but 4 stored)
        ]);
    }

    #[test]
    fn call_args() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    params: 2,
                    varargs: false,
                    fns: [],
                    consts: [],
                    ops: [
                        DEBUG(0),
                        DEBUG(1),
                        NOT(0,0),       // `false` => `true`
                        IFNOT(0,100),
                        NOT(1,1),       // `true` => `false`
                        IF(1,200),
                        NOT(2,2),       // `nil` => `true`
                        IFNOT(2,300),
                        RETURN(0,4),    // `true`, `false`, `true`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                LOADBOOL(1,0,false),
                LOADBOOL(2,1,true),
                CALL(0,4,3),    // call with 3 args (`false`, `true`, `true`, last disposed)
                                // store 2 return values in reg 0 and 1
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
            1: Value::TBool(false),
            2: Value::TBool(true),  // left over from before call
        ]);
    }

    #[test]
    fn varargs() {
        test!({
            stack: 4,
            fns: [
                fn {
                    stack: 3,
                    params: 1,
                    varargs: true,
                    fns: [],
                    consts: [],
                    ops: [
                        NOT(0,0),       // `false` => `true`
                        VARARGS(1,1),   // get 1st vararg (`true`)
                        IFNOT(1,100),
                        NOT(1,1),       // `true` => `false`
                        IF(1,150),
                        VARARGS(2,0),   // get all varargs ([`true`, `true`])
                        IF(1,500),
                        IFNOT(2,200),
                        IFNOT(3,300),
                        NOT(2,3),       // `true` => `false`
                        IF(1,600),
                        RETURN(0,4),    // `true`, `false`, `false`
                    ]
                }
            ],
            consts: [],
            ops: [
                FUNC(0,0),
                LOADBOOL(1,0,false),
                LOADBOOL(2,1,true),
                CALL(0,4,0),    // call with 3 args (`false`, [`true`, `true`] <- varargs)
                                // store all return values in regs 0..
                                // TODO check that dtop is set
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
            1: Value::TBool(false),
            2: Value::TBool(false),
            3: Value::TBool(true),  // after dtop, left over from call
        ]);
    }

    #[test] #[should_panic]
    fn meta() {
        // Make sure the `test!` macro correctly panics when a slot value mismatches

        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TBool(true),
        ]);
    }

    #[test] #[should_panic]
    fn stack_too_small() {
        run!({
            stack: 2,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,2),   // writes 0, 1, 2
                RETURN(0,1),
            ]
        });
    }

    #[test]
    fn simplest() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => [
            0: Value::TNil,
        ]);
    }

    #[test] #[should_panic]
    fn test_ret_panic() {
        // Tests the `test_ret!` macro
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [ Value::TInt(4) ]);
    }

    #[test]
    fn test_ret_main() {
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,1),
            ]
        } => return [ ]);
        test!({
            stack: 1,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,0),
                RETURN(0,2),
            ]
        } => return [ Value::TNil ]);
        test!({
            stack: 4,
            fns: [],
            consts: [],
            ops: [
                LOADNIL(0,3),
                LOADBOOL(2,0,true),
                LOADBOOL(3,0,false),
                RETURN(0,5),
            ]
        } => return [ Value::TNil, Value::TNil, Value::TBool(true), Value::TBool(false) ]);
    }

    #[test]
    fn simple() {
        // Tests simple opcodes (no metamethods, no calls, no dtop)

        test!({
            stack: 8,
            fns: [],
            consts: [
                Literal::TInt(7),
                Literal::TStr("test".to_string()),
            ],
            ops: [
                LOADNIL(0,0),
                LOADK(1,0),
                LOADK(2,1),
                TABLE(3),
                ARRAY(4),
                JMP(0),                 // no-op
                LOADBOOL(5,0,true),     // is executed
                JMP(1),
                LOADBOOL(5,0,false),    // skipped

                JMP(1),     // A: Jumps to C
                JMP(1),     // B: Jumps behind C
                JMP(-2),    // C: Jumps to B

                IFNOT(5,800),   // 5 should be `true`
                IF(0,800),      // 0 should be `nil`
                NOT(6,5),       // `false`
                NOT(7,0),       // `true`

                RETURN(0,1),
            ]
        } => [
            0: Value::TNil,
            1: Value::TInt(7),
            2: Value::TStr(_),
            3: Value::TTable(_),
            4: Value::TArray(_),
            5: Value::TBool(true),
            6: Value::TBool(false),
            7: Value::TBool(true),
        ]);
    }
}
